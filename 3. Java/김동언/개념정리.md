# Java - 김동언


### Java 정의, 장점, 단점

특징

- 객체 지향 프로그래밍
    - 캡슐화, 상속, 추상화, 다형성
    - 재사용성, 유지 보수 좋음
- 플랫폼 독립성
    - JVM 위에서 실행
- 자동 메모리 관리
    - 가비지 컬렉터 GC 관리
    - 개발자가 직접 관리할 필요 없음

단점

- 느린 실행 속도
    - 다른 언어에 비해 JVM을 한 번 더 거치므로 느림
- 높은 메모리 소비
    - GC를 사용하는데 추가적인 CPU가 사용됨

Java 객체 지향 프로그래밍 언어입니다. 객체 지향 프로그래밍 언어로 캡슐화, 상속, 추상화, 다형성 등을 지원하여 재사용성 유지 보수가 좋습니다.

Java의 특징으로는 플랫폼 독립성과 자동 메모리 관리가 있습니다. Java는 JVM 위에서 실행되므로 어떠한 운영체제에서든 실행이 가능합니다. Java는 가비지 컬렉션인 GC를 통해 자동으로 메모리를 관리할 수 있습니다.

하지만 Java는 느린 실행 속도와 높은 메모리 소비라는 단점이 있습니다. JVM을 한 번 더 거쳐서 실행되므로 다른 언어에 비해서 실행 속도가 느립니다. 또한 GC를 사용하는데 추가적인 CPU가 활용되어 메모리 소비가 높습니다.

Java를 장점이 더 크므로 여러 개발에서 활용되고 있습니다.


### 객체 지향 프로그래밍(OOP)과 특징 

Object-Oriented Programming, OOP

정의

- 데이터를 추상화 시켜 상태와 행위(데이터와 메소드)를 가진 객체로 만듬
- 이 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 기법
- 기능이 아닌 객체가 중심이며 ‘누가 어떤 일을 할 것인가’가 가 핵심
- 특징으로 캡슐화, 추상화, 추상화, 다형성 등이 있으며 모듈 재사용으로 확장 및 유지보수 용이

특징

- 캡슐화
    - 객체의 데이터와 메소드를 묶어서 구현 내용을 외부로 감추는 것
    - 객체의 데이터에 직접 접근하는게 아니라 인터페이스를 통해 접근
    - 데이터의 안정성 보장
- 추상화
    - 복잡한 시스템을 간단한 개념으로 표현하여 프로그래밍을 관리하기 쉬운 형태로 바꿈
    - 중요한 정보는 표시하고 불필요한 정보는 표시하지 않음
- 상속
    - 클래스가 다른 클래스로부터 데이터와 메소드를 물려 받는 것
    - 부모 클래스 : 물려줌, 자식 클래스 : 물려 받음
- 다형성
    - 같은 이름의 메소드가 다른 클래스에서 다양한 방식으로 실행
    - 대표적인 예시는 오버로딩, 오버라이딩
        - 오버로딩 : 이름은 같은데 입력 파라미터가 다른 메소드들을 여러 개 정의 (한 클래스)
        - 오버라이딩 : 상속 받은 메소드를 재정의

객체 지향 프로그래밍이란 데이터를 추상화시켜 상태와 행위를 가지는 객체로 만들고 객체끼리 상호작용을 통해 로직을 구상하는 프로그래밍 기법입니다.

객체 지향 프로그래밍은 기능이 아닌 객체의 중심을 두며 어떤 객체가 어떤 일을 할 것인지를 중점적으로 여깁니다.

객체 지향 프로그래밍은 캡슐화, 추상화, 상속, 다형성을 지원하며 재사용성과 유지보수를 좋게 만듭니다.

캡슐화는 객체의 데이터와 메소드를 묶어 외부로부터 숨기는 것 입니다. 객체의 데이터에 직접 접근하지 못 하게 하고 인터페이스를 통해 접근하게 합니다. 이를 통해 보안성이 좋아집니다.

추상화는 복잡한 시스템을 간단한 개념으로 표현한 것 입니다. 추상화를 하면 필요한 정보만 표시하고 불필요한 정보는 표시하지 않아 관리하기 쉬워집니다.

상속은 클래스가 다른 클래스에게 데이터와 메소드를 물려받는 것 입니다. 물려주는 클래스를 부모 클래스, 물려받는 클래스를 자식 클래스라 하며 재사용성과 중복코드를 줄일 수 있습니다.

다형성은 같은 이름의 메소드가 여러 방식으로 사용되는 것 입니다. 대표적인 예시로는 오버로딩과 오버라이딩이 있습니다. 오버로딩은 같은 클래스 내에서 같은 이름은 같지만 입력 파라미터가 다른 메소드들을 여러 개 정의한 것 입니다. 오버라이딩은 상속 받은 메소드를 재정의한 것 입니다.


### 객체 지향 설계 원칙(SOLID)

객체 지향 설계 원칙 SOLID은 겍체 지향 프로그래밍을 하면서 지켜하는 5가지 규칙입니다.

SRP, OCP, LSP, ISP, DIP 앞 글자를 따서 만들어졌습니다.

SOLD를 준수하면 유지보수와 확징이 쉬운 소프트웨어를 개발하는데 도움이 됩니다.

- 단일 책임 원칙 (SRP, Single Responsibilitt Principle)
    - 한 클래스는 하나의 책임을 가진다.
    - 변경이 일어났을 때 파급 효과가 적으면 잘 지은 것
    - 유지보수와 확장이 용이해짐
- 개방 폐쇄 원칙(OCP, Open Closed Principle)
    - 확장에 열려있고 수정에 닫혀있음
    - 기존의 코드를 변경하지 않고 확장할 수 있어야함
    - 변경에 따른 위험을 최소화하고 기존 코드의 재사용성을 높일 수 있음
- 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
    - 자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 함
    - 부모 클래스 대신 자식 클래스의 인스턴스를 사용했을 때 코드가 원래 의도대로 작동되어야 함
    - 상속의 올바른 사용, 부모 클래스와 자식 클래스 간의 호환성을 보장
- 인터페이스 분리 법칙(ISP, Interface Segregation Principle)
    - 인터페이스 여러 개가 하나 보다 좋음
    - 인터페이스를 특정 클라이언트에 맞추어 작은 단위로 분리해야 함
    - 불필요한 의존성을 줄이고 시스템의 유연성을 향상시킬 수 있음
- 의존 관계 역전 원칙(DIP, Dependenct Inversion Principle)
    - 추상화에 의존해야지 구체화 의존하면 안됨
    - 구체화에 의존하면 구체화가 변경되면 영향을 받기 때문
    - 가장 대표적인 방법은 의존성 주입(DI) 이다.
    - 시스템의 결합도를 낮추고 유연성과 재사용성을 높임


### JVM 

정의

- Java Vertual Machine
- JVM은 자바 프로그램을 실행하기 위한 환경을 제공하는 가상 머신
- 자바 언어로 작성된 소스 코드(.java)는 컴파일러에 의해 바이트 코드(.class)로 변환된다. 이 바이트 코드는 JVM에 의해 해석되고 실행된다.

특징

- 플랫폼 독립성 : Java 코드를 모든 운영체제에서 실행하게 해줌
- 메모리 관리 : 자동으로 메모리 할당 및 해제
- 가바지 컬렉션 : JVM은 가비지 컬렉션을 포함, 가비지 컬렉션은 더 이상 사용하지 않는 객체를 자동으로 감지하고 해제하여 메모리 누수를 방지함
- 보안 : 악성 코드로부터 시스템을 보호
- 성능 최적화 : JIT 컴파일러는 프로그램 실행 속도를 높임
    - JIT는 Java 바이트코드를 실시간으로 기계어 코드로 컴파일,
    - 동적 최적화 : 실행 중인 프로그램의 동작을 분석하여 성능을 최적화 하는 방식으로 컴파일
    - 가장 많이 사용되는 코드 영역을 식별, 최적화하여 기계어 코드로 반환

JVM이란 Java Vertual Machine으로 자바 프로그램을 실행하기 위한 환경을 제공하는 가상 머신입니다. Java 언어로 작성된 소스 코드는 컴파일러에 의해 바이트 코드로 변환됩니다. JVM은 이 바이트 코드를 실행시킵니다.

JVM 대표적 특징으로 플랫폼 독립성과 자동 메모리 관리가 있습니다. 어떠한 운영체제든 JVM이 설치되어 있으면 Java 코드를 실행할 수 있습니다. JVM은 가비지 컬렉션 GC를 포함하여 메모리를 자동으로 관리해줍니다.

JVM을 사용하면 자바 프로그램을 쉽게 개발하고 배포할 수 있습니다.


### JVM 메모리 구조 

Java 메모리 공간으로 Method, Heap, Stack 있으며 PC 레지스터, 네이티브 메소드로 구성되어 있습니다.

- Method
    - 클래스 정보, static을 선언된 변수, 전역 변수가 저장
    - 모든 스레드가 공유하는 영역
    - 프로그램의 시작부터 종료까지 메모리에 남아있음
- Heap
    - 런타임시 동적으로 생성된 인스턴스 변수가 저장
    - new 키워드로 생성되는 객체 배열 등이 Heap 영역에 저장
    - GC의 주요 메모리 관리 대상
- Stack
    - 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리에서 해제
    - 지역 변수, 매개 변수 등 임시적으로 사용되는 변수가 저장되는 영역
    - LIFO 구조로 변수에 새로운 데이터가 할당되면 이전 데이터는 지워짐 (Stack처럼 작동)
- PC 레지스터
    - 현재 수행중인 jvm이 명령어 주소를 저장하는 공간
    - 스레드가 시작될 때 생성
- 네이티브 메소드
    - 자바 외부의 언어로 작성된 네이티브 코드를 실행하는 영역
    - 네이티브 메소드란 주로 C나 C++ 같은 언어로 작성된 메소드
    - 네이티브 메소드의 사용은 성능 최적화와 시스템 레벨의 기능 접근이 필요한 경우에 유용
    - JVM의 가비지 컬렉션과 메모리 관리 기능의 영향을 받지 않기 때문에 메모리 누수와 같은 문제를 일으킬 수 있음

각 메모리 영역이 할당되는 시점

- Method : JVM이 동작해서 클래스가 로딩될 때 생성
- Heap : 런타임시 할당
- Stack : 메소드가 호출될 때 할당


### GC, Garbage Collection
정의

- 자동으로 메모리 관리
- 사용되지 않은 객체를 찾아내어 메모리 해제하여 메모리 누수 방지
- heap 메모리 영역이 주 대상 - 객체, 배열 같은 동적으로 할당된 데이터를 저장한 곳

동작 과정

JVM 어플리케이션 실행을 잠시 멈추고 GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업을 중단한 후 사용하지 않은 메모리를 제거(Mark and Sweep)하고 작업을 재게합니다.

1. 마킹 : 루트 집합으로 시작하여 도달 가능한 모든 객체를 마킹 (사용 중인 객체를 마킹)
2. 삭제 : 마킹되지 않은 객체들은 사용되지 않는 것으로 간주되어 메모리에서 제거

추가적으로 압축 단계가 일어날 수 있음

사용 중인 객체들을 메모리 상에서 가깝게 이동시켜, 메모리 단편화를 줄이고, 연속적인 메모리 할당을 용이하게 한다.


### Java 원시 타입 

Java 원시 타입 Primitive types

가장 기본적인 데이터 타입으로 간단한 값들을 저장하는 용도로 사용

원시 타입은 객체가 아니며 스택 메모리에 직접 저장되어 처리 속도가 빠르다

Java 원시 타입은 8 종류가 있다.

원시 타입 메모리 크기 (단위 : byte)

정수형

- byte : 1
- short : 2
- int : 4
- long 8

실수형

- float : 4
- double : 8

문자형

- char : 2

논리형

- boolean


### 오버로딩, 오버라이딩 

오버로딩, 오버라이딩은 다형성의 핵심입니다.

메소드를 다양한 형태로 사용하게 합니다.

오버로딩

- 같은 클래스 내에 메소드의 이름은 같지만 입력 파라미터가 다른 것

오버라이딩

- 상속 받은 메소드를 재정의해서 사용하는 것


### 추상클래스, 인터페이스 
추상 클래스는 상속을 받아 기능을 확장하는 목적이고, 인터페이스는 전체적인 설계도에 중점을 둔다.

공통점

- new 연산자로 인스턴스 생성이 불가능
- 사용하기 위해서는 하위 클래스에 확장, 구현해야 한다.

추상 클래스 (Abstract Class)

- 하나 이상의 추상 메소드가 포함된 클래스, abstract으로 정의함
- 추상 클래스는 객체 생성 불가, 상속을 통해 추상 메소드를 구현해야 객체 생성 가능
- 한 클래스는 하나의 추상 클래스만 상속 받을 수 있음 - 다중 상속 불가능
- 모든 접근 제어자 가질 수 있음

인터페이스 (Interface)

- 추상 메소드, 상수로 구현 (default method도 있음) implements로 정의함
- 인터페이스를 구현하는 모든 클래스에 특정한 메소드가 반드시 존재하도록 강제한다.
- 다중 상속 가능
- 인터페이스는 public만 가질 수 있음 (자바 9 버전부터 public, private 가질 수 있음)

인터페이스의 default method

- 추상 메소드가 아닌 구현된 메소드 입니다.
- 인터페이스에 새로운 메소드를 추가하면서 기존에 구현한 인터페이스에 영향을 적게 미침, 새로운 기능을 추상 메소드로 추가하면 구현체들 모두 그 기능을 구현해야하지만 default method를 사용하면 그럴 필요가 없음
- 예시로 List 인터페이스에는 sort 라는 default 메소드가 추가되어 있어 모든 객체들이 정렬 기능을 기본적으로 가짐


### 접근 제어자
래스, 변수 또는 메소드의 접근 범위를 설정하기 위해 사용하는 Java의 예약어이다.

접근 범위를 정의하며 캡슐화와 정보 은닉의 중요한 역할을 수행한다.

public, default, protected, private 4가지 종류가 있다.

- public : 누구든 접근 가능하다. 같은 프로젝트 내 어디서든 사용이 가능하다.
- default : 같은 패키지에서 접근 가능, 접근 제어자를 지정하지 않으면 default
- protected :  같은 패키지 접근 가능, 다른 패키지여도 상속 받았다면 접근 가능
- private : 같은 클래스에서만 접근 가능


### 싱글톤 패턴 

정의

- 싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴이다.
- 인스턴스가 1개만 존재하는 것을 보장하고 싶은 경우와 동일한 인스턴스를 자주 생성해야 하는 경우 주로 사용한다. (메모리 낭비 방지)
- 싱글톤의 대표적인 예시는 Spring Bean 이다. 스프링 컨테이너는 모든 빈들을 싱글톤으로 관리한다.

스프링은 요청할 때마다 새로운 객체를 생성해 반환하는 기능도 제공한다. (프로토타입 빈, @Scope(”prototype”))

### 클래스, 객체, 인스턴스 

클래스 : 객체를 생성하기 위한 템플릿, 객체의 상태와 행동을 정의

객체 : 클래스 정의된 속성과 행동을 실제로 가지는 실체

인스턴스 : 클래스부터 생성된 객체, 객체에 메모리가 할당되면 인스턴스가 된다.


### Generic 

정의

- 타입을 파라미터로 사용할 수 있게 해주는 기술
- 제네릭을 사용하데이터 타입을 클래스 내부에서 지정하는 것이 아니라 외부에서 지정할 수 있음

장점

- 컴파일 과정에서 타입 체크를 해주는 기능 (타입 안정성과 가독성이 높아짐)
- 형변환을 하는 번거로움을 줄여주며 코드를 간결하게 해줌 (Generic 이전에는 Object를 사용했음. 형변환을 할 때, Object 타입을 확인하고 변환하는 작업을 했음. Generic을 사용하면 이러한 작업을 생략할 수 있음)


### static 

static 키워드를 사용하면 변수나 메소드는 클래스가 메모리에 올라갈 때 자동으로 생성되며 클래스 로딩이 끝나면 바로 사용할 수 있다. 즉 인스턴스 생성 없이 바로 사용할 수 있다.

모든 객체가 메모리를 공유하고 GC 관리 영역 바께 있기 때문에 프로그램이 종료될 때까지 메모리에 값이 유지된 채로 존재한다.

- 정적으로 만듬.
- 변수나 메소드를 클래스 레벨로 선언하는데 사용
- 모든 인스턴스가 공유, 인스턴스를 생성하지 않고도 접근 가능
- 프로그램이 시작할 때 method 메모리 영역에 저장.
- static 변수 : 사용하면 클래스의 모든 인스턴스가 공유
- static 메소드 :  사용하면 클래스의 인스턴스를 생성하지 않고 호출 가능

static 사용하는 이유

static은 자주 변하지 않는 값이나 공통으로 사용되는 값 같은 공용자원에 대한 접근에 있어서 매번 메모리에 로딩하거나 값을 읽어들이는 것보다 일종의 전역변수와 같은 개념을 통해 접근하는 것이 비용도 줄이고 효율을 높일 수 있다.

인스턴스 생성 없이 바로 사용하기 때문에 프로그램 내에서 공통으로 사용되는 데이터들을 관리할 때 용이하다.



### final

final 정의

- 변수, 메소드, 클래스에 사용하여 불변으로 만듬
- final 변수 : 한 번 초기화 된 후 그 값을 변경 할 수 없음, 상수 선언 할 때 자주 사용
- final 메소드 : 오버라이딩 금지
- final 클래스 : 상속을 금지하는 클래스, 다른 클래스가 이 클래스를 상속 할 수 없음



### 불변 객체 

정의

- 불변 객체는 객체 생성 이후 내부의 상태가 변하지 않는 객체이다.
- Java에서 필드가 원시 타입인 경우 final 키워드를 사용해 불변 객체를 만들 수 있다.
- 참조 타입일 경우 추가적인 작업이 필요하다.

불변 객체를 만들기 위한 추가적인 작업

- 필드를 fianl, private을 선언한다. 생성자를 통해서만 생성 가능 그 이후에 변경 X
- 변경할 요소를 만들지 않는다. (setter 메소드를 제공하지 않기 )
- Collections 클래스에서 unmodifiableList, unmodifiableSet 메소드를 제공한다. 이 메소드는 뷰를 제공한다. 수정을 하려하면 예외가 발생한다.
- clone과 위에서 언급한 불변 객체로 만드는 메소드를 사용하여 getter를 반환한다.



### 불변 객체를 사용하는 이유

가장 중요한 이유는 스레드 안정성이다.

- Thread Safe하여 병렬 프로그래밍 유용하며 동기화를 고려하지 않아도 된다.
- 실패 원자적인 메소드를 만들 수 있다. (예외가 발생해도 예외 발생 전과 똑같은 상태여서 다음 로직을 처리할 수 있다.)
- 사이드 이팩트를 피해 오류를 최소화 할 수 있다.   (변수의 값이 바뀌어 예상치 못한 예외나 오류를 일으킬 가능성이 적다)
- 메소드 호출 시 파라미터 값이 변하지 않는 것을 보장할 수 있습니다.



### 재귀호출 

정의

- 함수가 자기자신을 호출
- 동일한 문제의 더 작은 부분 집합을 해결하는 방식으로 작동
- 종료 조건을 포함해야 함

장점

- 간결성 : 복잡한 알고리즘을 구현할 때 코드가 읽기 쉬어짐
- 문제 분해 : 복잡한 문제를 더 작고 단순한 여러 개의 하위 문제로 나눌 수 있음, 문제 해결에 용이

단점

- 성능 이슈 : 재귀 호출은 스택 메모리 사용, 많은 재귀 호출이 발생하면 스택 오버플로우 발생, 메모리 사용이 증가 됨
- 디버깅 어려움 : 오류 추적이 복잡해 질 수 있음



### JDK와 JRE 차이점 

JDK

- Java Development KIT
- 개발하는데 사용하는 도구
- JRE를 포함하고 있음

JRE

- Java Runtime Environment
- 자바로 만들어진 프로그램을 실행시키는데 필요한 도구가 들어있음
- 운영 서버 같은 곳에는 개발에 필요한 도구가 아닌 실행시키는 도구만 필요하기 때문에 JDK 대신 JRE를 설치



### Iterator 
컬렉션 내의 요소들을 순회하기 위한 인터페이스

컬렉션 구현에 관계없이 일관된 방법으로 요소들을 순회하고 접근 할 수 있음



### Reflection  

정의

- 프로그램이 실행 중에 자신의 구조를 검사하고, 수정할 수 있는 기능을 제공합니다.
- 실행 시간(run time)에 클래스, 인터페이스, 필드, 메소드 등에 대한 정보를 가져오거나 조작할 수 있습니다.
- Reflection은 동적 언어 기능을 지원하며, Java와 같은 정적 언어에서 런타임에 유연성을 제공합니다.

### 주요 사례

- 클래스 정보 접근

클래스의 이름, 슈퍼클래스, 구현된 인터페이스, 에노테이션 등의 정보를 조회할 수 있습니다.

- 동적 객체 생성

클래스 이름만 알고 있을 때, 해당 클래스의 인스턴스를 생성할 수 있습니다.

- 메소드 호출

메소드 이름과 파라미터 타입을 알고 있을 때, 해당 메소드를 동적으로 호출할 수 있습니다.

- 필드 접근 및 수정

클래스의 필드에 접근하여 값을 조회하거나 수정할 수 있습니다.

- 어노테이션 정보 접근

런타임에 어노테이션 정보를 조회하여, 그에 따른 로직을 실행할 수 있습니다.



### 생성자
생성자는 클래스와 같은 이름의 메소드로 객체가 생성될 때 호출되는 메소드이다.

명시적으로 생성자를 만들지 않아도 default로 만들어지며 생성자는 파라미터를 다르게 하여 오버로딩할 수 있다.


### Wrapper Class

기본 자료형(Primitive data type)에 대한 객체 표현을 Wrapper Class라고 한다.

기본 자료형을 Wrapper Class로 변환하는 것을 Boxing이라 한다.

Wrapper Class를 기본 자료형으로 변환하는 것을 UnBoxing이라 한다.

컬렉션 프레임워크(ArrayList, HashMap 등)는 객체만을 저장할 수 있습니다. Wrapper 클래스를 사용하면 컬렉션 프레임워크 같은 객체 지향 환경에 매끄럽게 통합할 수 있습니다.



### Synchronized

여러 개의 쓰레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 쓰레드를 제외하고 나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념이다.

데이터의 Thread-safe를 하기 위해 자바에서 Synchronized 키워드를 제공해 멀티 쓰레드 환경에[서 쓰레드간 동기화를 시켜 데이터의 Thread-safe를 보장한다.

Synchronized은 변수와 메소드에 사용해 동기화 할 수 있으며 Synchronized 키워드를 남발하게 되면 오히려 프로그램의 성능 저하를 일으킬 수 있다.



### new String()과 리터럴(””)

new String()은 new 키워드로 새로운 객체를 생성하기 때문에 Heap 메모리 영역에 저장된다.

리터럴(“”)은 Heap안에 있는 String Constant Pool 영역에 저장된다.


### String이 불변인 이유 

캐싱 기능에 의한 메모리 절약과 속도 향상

Java에서 String 객체들은 Heap의 String Pool이라는 공간에 저장된다.

참조하려는 문자열이 String Pool에 존재하는 경우 새로 생성하지 않고 Pool에 있는 객체를 사용하기 때문에 특정 문자열 값을 재사용하는 빈도가 높을수록 상당한 성능 향상을 기대할 수 있다.

Thread-Safe

String 객체는 불변이기 때문에 여러 쓰레드에서 동시에 특정 String 객체를 참조하더라도 안전하다.

보안 기능

중요한 데이터를 문자열로 다루는 경우 강제로 해당 참조에 대한 문자열 값을 바꾸는 것이 불가능하기 때문에 보안에 유리하다.



### String, StringBuffer, StringBuilder

String은 불변이지만 StringBuffer와 StringBuilder는 가변 객체 이다 .

문자열 조작이 빈번하게 발생하는 상황에서 StringBuffer, StringBuilder가 유용하다.

String 같은 경우 변경 될 때마다 새로운 String 객체를 생성하여 메모리, 성능 면에서 비효율적이다.

StringBuffer는 thread-safe하고 StringBuilder는 thread-safe하지 않다.

StringBuffer는 동기화를 지원하여 멀티 쓰레드 환경에서 주로 사용한다. synchronized로 선언되어 있다. 단일 스레드 환경에서는 StringBuilder에 비해 성능이 떨어질 수 있다.

StringBuilder는 동기화를 지원하지 않아 싱글 쓰레드 환경에서 주로 사용한다. StringBuffer 보다 빠른 성능을 제공하지만 멀티 스레드 환경에서는 안전하지 않다.



### 클래스 멤버 변수 초기화 순서

static 변수, 필드 변수, 생성자 순서이다.

static 변수 선언부 :

클래스가 로드 될 때 변수가 제일 먼저 초기화 된다.

필드 변수 선언부 :

객체가 생성될 때 생성자 block 보다 먼저 초기화 된다.

생성자 block :

생성자는 객체의 최종 초기화를 담당하며 필요한 경우 인스턴스 변수의 값을 재정의할 수 있다.

객체가 생성될 때 JVM이 내부적으로 locking(thread-safe) 하여 동시에 여러 스레드가 같은 클래스의 초기화 과정에 접근하는 것을 방지합니다. 이는 클래스의 정적 멤버가 안전하게 초기화될 수 있도록 보장합니다. (static variables, static methods)



### Inner Class(내부 클래스)

내부 클래스란 다른 클래스 내부에 선언된 클래스 이다.

내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근할 수 있다.

서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로 캡슐화를 증가하고 코드의 복잡성을 낮출 수 있다.

외부에서 내부 클래스에 접근할 수 없으므로 코드의 보안성을 높일 수 있다.



### Error와 Exception 

- Error

에러는 실행 중 일어날 수 있는 치명적인 오류입니다.

컴파일 시점에 체크할 수 없고 오류가 발생하면 프로그램은 비정상 종료됩니다.

예측 불가능한 UncheckedException에 속합니다.

예시 : OutOfMemoryError, StackOverflowError, NoClassDefFoundError

메모리 부족, 스택 오버플로우, 클래스의 정의를 찾을 수 없음

Error는 프로그램에서 적극적으로 처리하기보다는 피하는 것이 좋다.

- Exception

Exception은 Error 보다 비교적 경미한 오류이며 try-catch를 이용해 프로그램의 비정상 종료를 막을 수 있습니다.

프로그램 코드를 통해 처리할 수 있다. RuntimeException과 Checked Exception 두 유형으로 나누어진다.

RuntimeException : 주로 프로그래머의 오류로 발생

NullPointerException, IndexOutOfBoundsException, ArithmeticException 등이 있다.

Checked Exception : 체크 예외는 외부의 상황관 관려 있어 예측 가능한 상황에서 발생

IOException : input, output 작업 중에 발생하는 예외

SQLException : DB 접근과 관련된 작업 중에 발생하는 예외


### Optional API

개발할 때 가장 많이 발생하는 예외 중 하나는 NullPointException 입니다.

NPE를 피하려면 null 여부 검사를 필연적으로 해야 하는데 null 검사를 해야하는 변수가 많은 경우 코드가 복잡해지고 번거로워집니다.

Java 8부터는 Optional<T>를 제공하여 null로 인한 예외가 발생하지 않도록 도와주고 Optional 클래스의 메소드를 통해 null을 컨트롤 할 수 있습니다.

null 컨트롤하는 API 입니다.


### 컬렉션 프레임워크

다수의 데이터를 쉽고 효과적으로 관리할 수 있게 표준 방법을 제공하는 클래스의 집합입니다.

주요 인터페이스

- List
- Set
- Map
- Queue

주요 클래스

- ArrayList
- LinkedList
- HashSet
- TreeSet
- HashMap
- TreeMap
- PriorityQueue

### **컬렉션 프레임워크의 특징**

- **성능**: 각 컬렉션 구현체는 특정 상황에서 최적화된 성능을 제공합니다. 예를 들어, **`ArrayList`**는 빠른 임의 접근을, **`LinkedList`**는 요소의 빠른 추가와 제거를 지원합니다.
- **유연성**: 컬렉션 인터페이스를 구현하는 다양한 클래스들은 상황에 따라 적절히 선택하여 사용할 수 있습니다.
- **확장성**: 커스텀 컬렉션을 만들기 위해, 기존 인터페이스와 클래스를 상속하거나 구현할 수 있습니다.
- **일관성**: 일관된 인터페이스를 제공하여, 다양한 컬렉션을 쉽게 학습하고 사용할 수 있습니다.


### hashCode()와 equals() 

- hashCode()

객체의 해시 코드를 반환한다. 해시 코드는 객체를 식별하는데 사용하는 정수 값이다.

객체의 동등성을 판별하는 첫 번째 단계로 사용되며 실제 객체의 내용은 비교하지 않는다.

equals() 로 비교하여 동등하다고 판단된 두 객체는 반드시 같은 해시 코드를 반환해야 하기 때문이다.

기본적으로 메모리 주소를 기반으로 해시 코드를 생성합니다.

- equals()

두 객체가 동일한지 비교한다. 객체의 내용이 서로 같은지를 검사한다.

해시 기반 컬렉션에서는 hashCode() 메소드로 버킷을 찾은 후, 그 버킷 내에서 equals() 메소드를 사용해 정확한 객체를 찾는다.

equals는 객체의 실제 데이터를 비교하여 두 객체가 의미적으로 같은지를 결정한다.

equals()와 hashCode() 계약

1. 두 객체가 equals()에 의해 동등하다면 이들은 같은 해시 코드를 반환해야 한다.
2. 두 객체가 equals()에 의해 동등하지 않다면 해시 코드가 다를 수도 있지만 반드시 그럴 필요는 없다.



### final / finally / finalize

final

클래스, 메소드, 변수, 인자를 선언할 때 사용하며 한 번만 할당하고 싶을 때 사용합니다.

final 변수는 한 번 초기화하며 그 이후 변경할 수 없습니다.

final 메소드는 다른 클래스가 이 클래스르 상속할 때 메소드 오버라이딩을 금지합니다.

final 클래스는 다른 클래스에서 이 클래스를 상속할 수 없습니다.

finally

try-catch와 함께 사용하며 try-catch가 종료할 때 finally block이 수행되어 마무리 해줘야 하는 작업을 수행합니다. 자원 할당 해제를 합니다.

finalize

Object 클래스에 정의되어 있는 메소드며 GC에 의해 호출되는 메소드롤 건들이면 안되는 메소드 입니다. finalize() 메소드가 오버라이딩 되어 있으며 GC가 이루어질 떄 Garabage Collectiong 되지 않습니다. 이는 GC가 지연되어 Out of Memory Exception이 발생할 수 있습니다.



### 직렬화(Serialize)

시스템 내부에서 사용되는 객체 또는 데이터를 외부의 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터 변환하는 기술입니다. 반대로 직렬화된 바이트 형태의 데이터를 다시 객체로 변환하는 과정을 역직렬화라고 합니다.

객체 데이터를 바이트 형태로 변환하는 기술






