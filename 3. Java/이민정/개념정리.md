# 자바 - 이민정

<br>
<br>

## 자바 특징

- **운영체제에 독립적이다.**
    - 자바 응용프로그램은 운영체제나 하드웨어가 아닌 자바가상머신(JVM)하고만 통신하고 JVM이 자바 응용프로그램으로부터 전달받은 명령을 해당 운영체제가 이해할 수 있도록 변환하여 전달한다.
    - 자바로 작성된 프로그램은 운영체제에 독립적이지만 JVM은 운영체제에 종속적이어서 썬에서는 여러 운영체제에 설치할 수 있는 서로 다른 버전의 JVM을 제공하고 있다.
    - 자바로 작성된 프로그램은 운영체제와 하드웨어에 관계없이 실행 가능하며 이것을 ‘한 번 작성하면, 어디서나 실행된다. (Write once, run anywhere)’고 표현하기도 한다.
- **객체지향언어이다.**
    - 자바는 객체지향 프로그래밍언어 중 하나로 객체지향개념의 특징인 상속, 캡슐화, 다형성이 작 적용되어 있다.
- **자동 메모리 관리(Garbage Collection)**
    - 자바로 작성된 프로그램이 실행되면, 가비지 컬렉터(garbage collector)가 자동적으로 메모리를 관리해주기 때문에 프로그래머는 메모리를 따로 관리 하지 않아도 된다.
    - 가비지 컬렉터가 없다면 프로그래머가 사용하지 않는 메모리를 체크하고 반환하는 일을 수동적으로 처리해야 하지만, 자바는 자동으로 관리해주기 때문에 프로그래밍에 더 집중할 수 있도록 도와준다.
- **멀티 스레드 지원**
    - 일반적으로 멀티 스레드(multi-thread)의 지원은 사용되는 운영체제에 따라 구현방법도 상이하며, 처리 방식도 다르다. 그러나 자바에서 개발되는 멀티 스레드 프로그램은 시스템과는 관계없이 구현가능하며, 관련된 라이브러리(Java API)가 제공되므로 구현이 쉽다.
    - 여러 스레드에 대한 스케줄링(scheduling)을 자바 인터프리터가 담당하게 된다.
- **동적 로딩 지원**
    - 보통 자바로 작성된 애플리케이션은 여러 개의 클래스로 구성되어 있다. 자바는 동적 로딩을 지원하기 때문에 실행 시에 모든 클래스가 로딩되지 않고 필요한 시점에 클래스를 로딩하여 사용할 수 있다는 장점이 있다.
    - 그 외에도 일부 클래스가 변경되어도 전체 애플리케이션을 다시 컴파일하지 않아도 되며, 애플리케이션의 변경사항이 발생해도 비교적 적은 작업만으로도 처리할 수 있는 유연한 애플리케이션을 작성할 수 있다.

### 장점

- JVM 위에서 동작하기 때문에 운영체제에 독립적이다.
- 가비지 컬렉터를 통한 자동 메모리 관리가 가능하다.

### 단점

- JVM 위에서 동작하기 때문에 실행 속도가 상대적으로 느리다.
- 다중 상속이나 타입에 엄격하며, 제약이 많다.


<br>
<br>


## JVM(Java Virtual Machine)

JVM은 자바 가상머신으로, 자바를 실행하기 위한 가상 기계라고 할 수 있다. 자바로 작성된 애플리케이션은 모두 JVM에서만 실행되기 때문에, 자바 애플리케이션이 실행되기 위해서는 반드시 JVM이 필요하다. 일반 애플리케이션의 코드는 OS만 거치고 하드웨어로 전달되는데 비해 자바 애플리케이션은 JVM을 한 번 더 거치고, 하드웨어에 맞게 완전히 컴파일된 상태가 아니고 실행 시에 해석(interpret)되기 때문에 속도가 느리다는 단점을 갖고 있다. 

그러나 요즘엔 바이트코드(컴파일된 자바코드)를 하드웨어의 기계어로 바로 변환해주는 JIT 컴파일러와 향상된 최적화 기술이 적용되어서 속도의 격차를 많이 줄였다.  

<br>

### JVM 메모리 구조
<img width="392" alt="jvm" src="https://github.com/simol-study/cs/assets/79951187/b085842b-e766-4773-bf9c-f13238832f73">




- **클래스 로더(Class Loader)**
- **실행 엔진(Execution Engine)**
    - 인터프리터(Interpreter)
    - JIT 컴파일러(Just-In-Tiem)
    - 가비지 컬렉터(Garbage Collector)
- **런타임 데이터 영역(Runtime Data Area)**
    - 메서드 영역
    - 힙 영역
    - PC Register
    - 스택 영역
    - 네이티브 메서드
- **JNI - 네이티브 메서드 인터페이스(Native Method Interface)**
- **네이티브 메서드 라이브러리(Native Method Library)**

<br>

#### 클래스 로더(Class Loader)

클래스 로더는 JVM 내로 클래스 파일(*.class)을 동적으로 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다. 즉, 바이트 코드(.class)들을 엮어서 JVM의 메모리 영역인 Runtime Data Areas에 배치한다. 

#### 실행 엔진(Execution Engine)

실행 엔진은 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행한다. 자바 바이트 코드(*.class)는 기계가 바로 수행할 수 있는 언어보다는 가상머신이 이해할 수 있는 중간 레벨로 컴파일 된 코드이다. 그래서 실행 엔진은 이와 같은 바이트 코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경해준다.

- **인터프리터(Interpreter)**
    - 바이트 코드 명령어를 하나씩 읽어서 해석하고 바로 실행한다.
    - JVM 안에서 바이트 코드는 기본적으로 인터프리터 방식으로 동작한다. 다만 같은 메서드라도 여러 번 호출 된다면 매번 해석하고 수행해야 돼서 전체적인 속도는 느리다.
- **JIT 컴파일러(Just-In-Tiem)**
    - 인터프리터의 단점을 보완하기 위해 도입된 방식으로 반복되는 코드를 발견하여 바이트 코드 전체를 컴파일하여 Native Code로 변경하고 이후에는 해당 메서드를 더이상 인터프리팅 하지 않고 캐싱해두었다가 네이티브 코드로 직접 실행하는 방식이다.
    - 하나씩 인터프리팅하여 실행하는 것이 아니라, 컴파일된 네이티브 코드를 실행하는 것이기 때문에 전체적인 실행 속도는 인터프리팅 방식보다 빠르다.
    - 하지만 바이트 코드를 네이티브 코드로 변환하는 데에도 비용이 소요되므로, JVM은 모든 코드를 JIT 컴파일러 방식으로 실행하지 않고 인터프리터 방식을 사용하다가 일정 기준이 넘어가면 JIT 컴파일 방식으로 명령어를 실행하는 식으로 진행한다.
- **가비지 컬렉터(Garbage Collector)**
    - 힙 메모리 영역에 생성된 객체들 중에서 참조되지 않은 객체들을 탐색 후 제거하는 역할을 한다.

#### 런타임 데이터 영역(Runtime Data Area)

JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다.

- **메서드 영역**
    - JVM에서 읽어들인 클래스와 인터페이스에 대한 런타임 상수 풀, 메서드와 필드, static 변수, 메서드 바이트 코드 등을 보관.
    - 런타임 상수 풀 : 클래스와 인터페이스 상수, 메서드와 필드에 대한 모든 레퍼런스 저장, JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리 상 주소를 찾아 참조
- **힙 영역**
    - 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 메모리 영역
    - new 연산자를 통해 생성한 객체, 또는 인스턴스와 배열을 저장
    - JVM 관리 대상
- **PC Register**
    - 스레드가 시작될 때 생성되며, 생성될 때마다 생성되는 공간으로 스레드마다 하나씩 존재한다. 스레드가 어떤 부분을 무슨 명령으로 실행해야할 지에 대한 기록을 하는 부분이다.
    - 현재 실행 중인 JVM 주소를 가지고 있다.
- **스택 영역**
    - 메서드 호출 시마다 각각의 스택 프레임(그 메서드만을 위한 공간) 생성.
    - 메서드 안에서 사용되는 값들을 저장하고, 호출된 메서드의 매개변수, 지역변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장.
    - 메서드 수행이 끝나면 프레임 별로 삭제.
- **네이티브 메서드**
    - 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역.
    - 네이티브 메서드의 매개변수, 지역변수 등을 바이트코드로 저장.

<br>
<br>

### 원시 타입

- **정수형**
    - byte(4 byte)
    - short(2 byte)
    - int(4 byte)
    - long(8 byte)
- **실수형**
    - float(4 byte)
    - double(8 byte)
- **문자형**
    - char(2 byte)
- **논리형**
    - boolean(1 byte)

<br>
<br>

### 오버라이딩(Overriding), 오버로딩(Overloading)

- **오버라이딩**
    - 상위 클래스에 있는 메서드를 하위 클래스에서 재정의 하는 것.
    - 상속 관계에서 다형성을 구현하는 데 사용된다. 이를 통해 상위 클래스의 메서드를 호출하더라도 하위 클래스의 오버라이드된 메서드가 실행된다.
    - 오버라이딩된 메서드는 상위 클래스의 **메서드와 메서드명, 매개변수 타입, 반환 타입**이 동일해야 함.
    - **접근 제어자**는 상위 클래스의 메서드보다 **좁은 범위**로 **변경**할 수 **없다.**
    - 상위 클래스의 메서드보다 **많은 수의 예외**를 **선언**할 수 **없다**.
    - 예) toString() 메서드 재정의 하여 사용.
- **오버로딩**
    - 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메서드를 여러 개 정의하는 것.
    - 메서드의 이름이 동일하지만 **매개변수의 타입, 개수, 또는 순서가 다른 경우**에 사용
    - 같은 동작을 하는 메서드들을 하나의 이름으로 그룹화하여 코드를 더 간결하고 읽기 쉽게 만들어주고 메서드의 이름을 절약할 수 있다는 장점이 있음.
    - 호출 시 전달된 인자의 개수와 타입에 따라 자동으로 해당하는 메서드가 선택됨.
    - 예) print() 메서드

<br>
<br>

# 객체지향

## 객체지향 프로그래밍 특징

### 추상화

- 공통된 속성과 행위를 묶어서 표현하는 방법.
- 객체들의 공통된 특성을 추상화하여 정의함으로써 코드의 가독성을 향상시키고 중요한 부분에 집중할 수 있다.
- 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써  프로그램을 간단하게 만든다.

### 캡슐화

- 객체의 내부 구조 및 데이터를 캡슐처럼 감싸 외부에서 직접 볼 수 없게 은닉하여 보호하는 것.
- 높은 응집도(동일 클래스만 변경)와 낮은 결합도(다른 클래스 간섭 배제)를 유지할 수 있도록 설계하는 것.
- 실제로 구현되는 부분을 외부에 드러나지 않도록 하여 정보를 은닉할 수 있다.
- 데이터 캡슐화 : 필드와 메서드를 클래스로 묶는 방법
- 은닉화 : 외부에서 객체 상태 변경에 제한을 두는 방법(접근 제어)

### 상속

- 클래스의 속성과 행위를 하위 클래스에 물려주거나 하위 클래스의 속성과 행위를 물려받는 것을 말함
- 기존 코드를 재활용해서 새로운 클래스를 생성하는 것
- 새로운 클래스가 기존의 클래스의 데이터와 연산을 이용할 수 있게 하는 기능

### 다형성

- 동일 요청에 대해 서로 다른 방식으로 응답할 수 있는 방법
- 어떠한 요소에 여러 개념을 넣어 놓는 것
- 오버로딩, 오버라이딩

<br>
<br>

## 객체지향 5대 설계원칙

### SRP(Single Responsibility Principle)

- 단일 책임 원칙
- 클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.
- 프로그래밍의 유지보수성을 높이기 위한 설계 기법
- ‘책임’이라는 의미는 하나의 ‘기능 담당’으로 보면 됨.

### OCP(Open-Closed Principle)

- 개방-폐쇄 원칙
- 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
- 기능 추가 요청이 오면 클래스를 확장을 통해 손쉽게 구현하면서 확장에 따른 클래스 수정은 최소화 하도록 프로그램을 작성해야 하는 설계 기법.
- **확장에 열려있다** → 새로운 변경 사항이 발생했을 때 유연하게 코드를 추가함으로써 큰 힘을 들이지 않고 애플리케이션의 기능을 확장할 수 있음.
- **변경에 닫혀있다** → 새로운 변경 사항이 발생했을 때 직접적으로 객체를 수정하는 것을 제한함.
- 추상화 사용을 통한 관계 구축 권장을 의미.
- 다형성과 확장을 가능케 하는 객체지향의 장점을 극대화하는 기본적인 설계 원칙.

### LSP(Liskov Substitution Principle)

- 리스코프 치환 원칙
- 서브 타입은 언제나 부모 타입으로 교체할 수 있어야 한다는 원칙
- 다형성의 특징을 이용하기 위해 상위 클래스 타입으로 객체를 선언하여 하위 클래스의 인스턴스를 받으면, 업캐스팅된 상태에서 부모의 메서드를 사용해도 동작이 의도대로 흘러가야 하는 것을 의미.
- 부모 메서드의 오버라이딩을 조심스럽게 따져가며 해야 한다. 부모 클래스와 동일한 수준의 선행 조건을 기대하고 사용하는 프로그램 코드에서 예상치 못한 문제를 일으킬 수 있기 때문

### ISP(Interface Segregation Principle)

- 인터페이스 분리 원칙
- 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
- 인터페이스의 단일 책임 강조
- 클라이언트를 기준으로 분리함으로써, 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는 것이 목표

### DIP(Dependency Inversion Principle)

- 의존 역전 원칙
- 상위 모듈은 하위 모듈에 종속 되면 안되고, 둘 다 추상화에 의존해야 한다.
- 어떤 클래스를 참조해서 사용해야 하는 상황이 생긴다면, 그 클래스를 직접 참조하는 것이 아니라 그 대상의 상위 요소(추상 클래스 or 인터페이스)로 참조하라는 원칙.
- 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
- 각 클래스들 간의 결합도를 낮추는 것.
