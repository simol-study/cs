# 네트워크

네트워크란 두 대 이상의 컴퓨터들을 연결하고 서로 통신할 수 있는 것을 말한다. 노드와 링크로 서로 연결되는 라우터, 스위치 등의 물리적인 장부터 데이터를 주고 받는데 필요한 메시지와 규약을 모두 아우르는 통신 과정 전체를 가리키는 개념이다. 

## 네트워크의 종류

- LAN(Local Area Network) : 집, 학교, 회사 등에서 사용하는 공유기를 중심으로 하는 소규모의 근거리 영역 네트워크이다. 물리적으로 가깝고 통신에 필요한 선이 짧기 때문에 데이터를 주고 받는데 오류가 적고 속도가 빠르다.

- WAN(Wide Area Network) : 넓은 영역을 연결하는 광역 네트워크이다. SKT, KT와 같은 인터넷 서비스 제공자(ISP; Internet Service Provider)들이 설치한 회선을 통해 사용할 수 있으며 LAN에 비해 속도가 느리고 오류가 발생할 확률이 높아진다. 

# **HTTP (Hyper Text Transfer Protocol)**

일반적으로 웹 브라우저인 클라이언트와 서버 사이에서 데이터를 주고 받기 위한 통신 프로토콜로 애플리케이션 계층의 프로토콜이다. 상태 정보를 서버에 저장하지 않는 Stateless 특징과 클라이언트의 요청에 맞는 응답을 보낸 후 연결을 끊는 Connectionless한 특징을 가지고 있다. 통신 간의 연결이나 상태 정보를 처리할 필요가 없어 서버 디자인이 간단하고 각 요청에 대해 독립적인 응답만 보내주면 된다.

그러나 무상태 프로토콜은 상태 정보가 저장되지 않기 때문에 매번 인증이 필요하여 이러한 점을 보완하기 위해 쿠키와 세션을 사용하게 된다. 또한, HTTP/1.1부터는 비연결성을 보완하기 위해 HTTP 지속 연결(Persistent Connections)을 통해 한 번의 클라이언트 요청에 여러 번의 서버 응답을 받을 수 있도록 하고 있다.

<img width="684" alt="Screenshot 2024-02-29 at 3 49 25 AM" src="https://github.com/SuhyungK/SuhyungK/assets/97926368/99f4a8ae-b06a-417d-ab6b-33a077f18e5d">

## **무상태 프로토콜 (Stateless)**

- 서버가 클라이언트의 상태를 보존하지 않음
- 통신에 필요한 모든 상태 정보는 클라이언트에서 서버에 요청을 보낼 때 보내게 됨
- 서버가 상태 정보를 저장하고 있지 않으므로 scale out에 유리함

## **비연결성 프로토콜 (Connectionless)**

- 클라이언트가 요청했을 때 서버가 그에 맞는 응답을 보내고 연결을 끊는 방식
- TCP/IP는 기본적으로 연결을 유지하는 모델이나 HTTP는 연결을 유지하지 않는 모델
- 매 요청마다 TCP 3-way handshake 가 이루어지게 됨
- HTTP/1.1이후부터는 HTTP 지속 연결 사용(HTTP Keep Alive)

## HTTP 와 HTTPS

HTTP는 웹 상에서 데이터를 주고 받기 위한 클라이언트-서버 기반의 프로토콜이다. 80번 포트를 사용하게 된다. HTTP는 암호화 되지 않은 평문 데이터를 전송하는 프로토콜이었기 때문에 중요한 정보 등을 제3자가 조회할 수 있다는 보안상 취약점이 존재했다. 이를 해결하기 위해 HTTPS 를 사용하게 된다.

### HTTPS (Hyper Text Transfer Protocol Secure)

HTTP에 데이터 암호화가 추가된 프로토콜이다. HTTP와 다르게 443번 포트를 사용한다. SSL 혹은 TLS 를 통해 데이터를 암호화하게 된다. 

HTTPS 는 대칭키와 비대칭키 암호화를 모두 사용한다. 서버와 클라이언트 간에 세션키를 통해 데이터를 암호화하게 되는데 이때 세션키는 대칭키로 만들어지며, 세션키를 공유하는 과정에서는 비대칭키를 사용하게 된다. 

### SSL 핸드셰이크

<img width="704" alt="Screenshot 2024-02-29 at 3 50 00 AM" src="https://github.com/SuhyungK/SuhyungK/assets/97926368/2785ae00-fee8-425a-9885-94190285615c">


1. 클라이언트 → 서버 : 브라우저(클라이언트)가 지원하는 암호화 정보 전송
2. 서버 → 클라이언트 : 서버가 지원하는 암호화 방식, SSL 인증서 전송
3. 클라이언트는 해당 SSL 인증서 유효성 검증
4. 클라이언트는 난수를 생성하고 서버에서 보낸 공개키로 암호화
5. 서버는 암호화 된 난수를 비밀키로 복호화하고 이를 사용해서 세션키 생성

### 대칭키 암호화와 비대칭키 암호화

- 대칭키 암호화 : 클라이언트와 서버가 동일한 키를 사용하여 암호화/복호화를 진행
- 비대칭키 암호화 : 1개의 쌍으로 구성된 공개키와 비밀키를 사용하여 암호화/복호화

## HTTP 버전

### HTTP/0.9

- 가장 초기 버전
- HTML 문서를 가져오기만 하는 GET 메서드만 존재

### HTTP/1.0

- HTTP 메서드와 요청/응답 헤더 추가
- HTTP 버전 정보 추가
- 상태 코드(Status Code)가 응답에 추가
- 응답 헤더의 Content-Type 덕분에 HTML 이외의 형식도 전송 가능
- 1 커넥션 당 하나의 요청과 응답만 처리 가능(단기 커넥션)

HTTP 1.0 방식은 HTTP의 비연결성 특징으로 인해 단기 커넥션(Short-lived connection)한 특징을 가졌다. 하나의 요청에 대해 하나의 응답 처리만 가능한 것인데, 서버에 요청을 할 때마다 매번 새로운 연결을 해야 했다. 서버 부하 비용이 증가하는 문제가 발생하여 해당 문제를 보완한 HTTP/1.1 이 나오게 된다. 

### HTTP/1.1

- 지속 연결 (Persistent connection)
    - 지정한 timeout 동안 요청에 대한 커넥션을 닫지 않아 하나의 요청에 대해 여러 응답 처리가 가능
    - 클라이언트의 요청에 keep-alive 헤더 사용
- HOST 헤더 추가 : 동일한 IP 주소에 대해 다른 도메인을 호스트하는 기능

### HTTP/2.0

- HTTP 메시지가 바이너리 프레임으로 인코딩되어 데이터 파싱 및 전송 속도 증가
- 하나의 커넥션에 여러 메시지 스트림을 응답 순서에 상관없이 주고 받을 수 있게 됨(멀티플렉싱)
- 서버 푸시(Server Push) : 클라이언트의 요청에 대해 필요할 것 같은 리소스를 미리 전송
- 리소스 간 의존관계 설정
- 헤더 압축 전송 : 중복 되는 필드 재전송 X

### HTTP/3.0

- UDP 기반 프로토콜인 QUIC를 사용하여 통신하는 프로토콜
- 패킷 손실에 걸리는 시간 단축
- 독립 스트림으로 HOLB(Hold Of Line Blocking) 문제 해결

## HTTP 상태 코드

HTTP 요청에 대해 응답이 성공적으로 완료되었는지를 짧은 메세지로 나타내는 것이다. 

### 1xx 정보 응답

### 2xx 성공 응답

- 200 OK
- 201 Created
- 204 No Content

### 3xx 리다이렉션 메시지

### 4xx 클라이언트 에러

- 400 Bad Request
- 401 Unauthorized
- 403 Forbidden
- 404 Not Found
- 405 Method Not Allowed

### 5xx 서버 에러

- 500 Internal Server Error
- 502 Bad Gateway
- 504 Gateway Timeout : 서버가 게이트웨이 역할을 하고 있으며 시간 내에 응답을 받을 수 없음

---

# **쿠키와 세션**

쿠키와 세션은 사용하는 이유는 HTTP의 특성인 무상태와 비연결성을 보완하기 위해서다. HTTP 프로토콜은 클라이언트가 서버에 요청을 하면 서버가 응답을 한 후 연결을 끊고, 클라이언트의 상태를 서버에 저장하지 않는다. 

## 쿠키

HTTP 쿠키는 서버가 클라이언트에 전송하는 작은 데이터 조각이다. 클라이언트는 해당 데이터를 저장해두었다가 동일한 서버에 재 요청 시 저장된 데이터를 함께 전송한다. 쿠키는 요청이 같은 클라이언트로부터 들어왔는지를 판단할 때 사용하게 됩니다. 이를 통해서 사용자의 로그인 상태를 유지할 수 있습니다. 

최근에는 클라이언트 측에 정보를 저장할 때 쿠키 보다 Modern APIs의 종류인 웹 스토리지 API(로컬 스토리지나 세션 스토리지)와 IndexedDB를 사용하는 것을 권장한다. 클라이언트의 쿠키에 정보를 저장하게 되면 매 요청마다 쿠키가 함께 전송되기 때문에 성능이 떨어지는 원인이 될 수 있다. 

 

### 쿠키의 목적

- 세션 관리 (Session Management) : 서버에 저장되는 로그인 정보, 장바구니, 게임 스코어 등
- 개인화 : 다크 모드, 테마, 언어 설정 등
- 트래킹 : 사용자 행동 기록하고 분석

### 쿠키의 동작 원리

1. 클라이언트가 요청을 보내면 서버에 클라이언트의 정보를 담은 쿠키를 생성 
2. set-cookie 옵션을 통해 쿠키를 포함한 응답을 보냄
3. 해당 쿠키를 클라이언트의 PC에 저장하고 
4. 다시 서버에 요청을 보낼 때 cookie 옵션을 통해 해당 데이터 전송

### 쿠키의 특징

- 이름, 값, 만료인(저장기간), 경로 정보로 구성
- 클라이언트에 총 300개의 쿠키 저장 가능
- 하나의 도메인 당 20개의 쿠키
- 하나의 쿠키는 4KB까지 저장 가능

## 세션

서버 쪽에 클라이언트의 상태 정보를 저장하여 상태를 유지시키는 기술이다. 클라이언트가 웹 서버에 접속해서 종료할 때까지의 상태 정보를 저장하는 것이다. 

### 세션 특징

- 서버에 클라이언트의 정보를 저장하게 됨
- 클라이언트가 웹 서버에 접속해서 종료할 때까지의 상태 정보를 저장하며 브라우저를 닫으면 삭제
- 쿠키에 비해 보안이 좋음
- 각 클라이언트에 고유한 Session Id를 부여

### 세션 동작 원리

1. 서버가 요청을 보낸 클라이언트에게 set-cookie 값으로 클라이언트 식별자인 session-id 를 전송
2. 클라이언트는 해당 session-id 를 클라이언트의 PC에 저장
3. 클라이언트는 해당 서버에 접속할 때 쿠키를 사용해 session-id를 서버에 전달

## 토큰 기반 인증

인증받은 사용자에게 토큰을 발급하고, 서버에 요청을 보낼 때 헤더에 토큰을 함께 보내도록 하여 인증을 처리하는 방식이다. 이러한 방식에서는 클라이언트의 상태 정보를 서버나 세션에 유지하지 않으므로 Stateless 한 특징을 갖는다. 

기존의 세션 기반 인증은 클라이언트의 상태를 서버에 저장해야 하는 stateful 한 방식으로 서버의 용량을 차지하고 사용자가 증가함에 따라 서버를 확장하는데 어려움이 있을 수 있다는 단점이 있다. 또한 추가로 조회하는 과정을 필요로 하기 때문에 오버헤드가 발생할 수 있다. 토큰 기반 인증은 세션 기반과 달리 클라이언트에 정보를 저장하고 관리하기 때문에 stateless 한 특징을 가질 수 있다. 

<img width="522" alt="Screenshot 2024-02-29 at 3 50 24 AM" src="https://github.com/SuhyungK/SuhyungK/assets/97926368/4b0bd76e-f99f-4231-b8b2-3d4937896976">


## JWT (Json Web Token)

Json 포맷을 사용하여 사용자에 대한 정보를 암호화하는 Web Token이다. JWT 는 토큰 자체를 정보로 사용하는 Self-Contained 방식으로 정보를 전달한다. 

### JWT 구조

헤더(Header), 페이로드(Payload), 서명(Signature) 3부분으로 이루어지며 각 부분은 Json 형태인 Base64Url로 인코딩 되어 표현된다. 각 부분을 이어주기 위해서 . 구분자를 사용해 구분하게 된다. 

- Header
    - typ : JWT 와 같은 토큰의 정보 저장
    - alg : 서명과 토큰 검증에 사용되는 해싱 알고리즘
- Payload : 토큰에서 사용할 실제 데이터들
    - Registered Claim : 토큰 정보를 표현하기 위해 이미 정해진 종류의 데이터
    - Public Claim : 공개용 정보를 저장, 충돌 방지를 위해 URI 포맷 사용
    - Private Clam : 사용자 정의 클레임, 서버와 클라이언트 사이의 임의로 지정한 정보 저장
- Signature : 토큰을 인코딩하거나 유효성 검증할 때 사용하는 고유한 암호화 코드

### JWT 특징

- Self-contained : 토큰 자체에 정보를 담고 있다
- 토큰 길이 : 정보가 많아질수록 토큰의 길이가 늘어나 네트워크에 부하를 줄 수 있다
- Stateless : JWT는 상태를 저장하지 않기 때문에 한 번 만들어지면 제어가 불가능, 토큰을 임의로 삭제할 수 없기 때문에 만료 시간을 반드시 넣어주어야 한다.
- Payload : 페이로드 자체는 암호화 된 것이 아니기 때문에 암호화하거나 중요 데이터를 넣으면 안 된다
- 서버가 무상태를 유지할 수 있어서 서버 확장성
- 다른 로그인 시스템에 접근 및 권한 공유 가능
- 사용자에 대한 정보를 페이로드에 추가하면 DB 조회를 하지 않아도 된다는 장점

---

# OSI 7 계층

네트워크 통신이 일어나는 과정을 7단계로 나눈 것이다. 계층을 나눈 이유는 통신이 일어나는 과정을 단계별로 파악하기 위함이다. 흐름을 쉽게 이해할 수 있고 특정 곳에 이상이 생겼을 때 해당 단계만 해결하면 되기 때문이다.

<img width="742" alt="Screenshot 2024-02-29 at 3 51 09 AM" src="https://github.com/SuhyungK/SuhyungK/assets/97926368/9e3c344e-c82d-44c2-a65e-970eaab33bd7">

### 1계층 - 물리 계층

전기적 특성을 사용해서 통신 케이블로 데이터를 전송하는 계층이다. 통신 단위는 비트이며 1과 0으로 나타내어진다. 전기적인 신호로 데이터를 주고 받는 기능만 수행하는 계층으로 대표적인 장비는 통신 케이블, 리피터, 허브 등이 있다. 

### 2계층 - 데이터링크 계층

통신에서의 오류를 찾아주고 재전송하는 등 안전한 정보 전달을 수행하는 역할을 하는 계층이다. MAC 주소를 통해 통신하게 되며 통신 단위는 프레임이다. 대표적인 장비로는 브리지, 스위치 등이 있다. 

### 3계층 - 네트워크 계층

경로와 주소를 정하고 패킷을 전달해주는 역할을 수행하는 계층이다. 목적지까지 가장 안전하고 빠르게 데이터를 보내기 위해 최적의 경로를 설정한다. 전송 단위는 패킷이며 대표적인 장비는 라우터와 L3 스위치가 있다.

### 4계층 - 전송 계층

사용자들 간의 신뢰성 있는 데이터를 주고 받기 위한 역할을 하는 계층이다. 오류 검출 및 복구, 흐름 제어와 중복 검사 등을 수행한다. 데이터 전송을 위해 포트 번호를 사용하며 전송 단위는 세그먼트이다. 대표적인 프로토콜로는 TCP와 UDP가 있다.

### 5계층 - 세션 계층

### 6계층 - 표현 계층

### 7계층 - 응용(어플리케이션) 계층

사용자와 가장 가까운 계층으로 HTTP, FTP 등의 프로토콜이 속하게 된다.

# TCP/IP 4계층

> 현대의 인터넷 및 네트워크에서는 대부분 TCP/IP 계층을 사용하며 OSI 7계층의 경우 학술적인 목적으로 사용된다. TCP/IP는 4계층이며 전송/응용 계층이 병합되어 있는 반면 OS 계층은 전송, 세션, 표현 계층이 나누어져 있다는 차이가 있다.
> 

IP 프로토콜은 해당 IP 주소로 데이터를 패킷이란 단위로 나누어 빨리 보내는 것을 목적으로 하며, TCP 는 신뢰성 있는 연결을 바탕으로 데이터의 전송 순서를 보장하는 역할을 수행한다.

<img width="659" alt="Screenshot 2024-02-29 at 3 51 41 AM" src="https://github.com/SuhyungK/SuhyungK/assets/97926368/322e14f4-1737-4a92-ae58-1caebc7bb32e">

### 1계층 - Network Layer

- 노드 간의 신뢰성 있는 데이터 전송을 담당하는 계층
- OSI 7계층의 물리 계층 + 데이터 링크 계층
- MAC 주소를 사용해 각 데이터가 알맞은 하드웨어로 전송되도록 하고 데이터 패킷을 전기 신호로 변환

### 2계층 - 인터넷 계층

- IP를 담당하는 계층으로 가장 효율적인 방법으로 데이터 패킷을 목적지로 빠르게 전송하는 역할
- 신뢰성 있는 패킷 전달 여부 보장 X, 경로를 설정해 가장 빠르게 보내는 것 보장
- 프로토콜로는 IP, ICMP, ARP, RARP 등
    - ARP : IP 주소 → MAC 주소
    - RARP : MAC 주소 → IP 주소

### 3계층 - 전송 계층

- TCP/UDP

### 4계층 - 애플리케이션 계층

- HTTP/FTP
- 서버나 클라이언트의 응용 프로그램
- DNS, SNMP, FTP, HTTP

---

# TCP 와 UDP

데이터를 전송하기 위한 프로토콜

<img width="598" alt="Screenshot 2024-02-29 at 3 52 02 AM" src="https://github.com/SuhyungK/SuhyungK/assets/97926368/f8c74263-b094-45fc-81be-0a648a2d1476">

## TCP (Transmission Control Protocol)

- 연결 지향 방식으로 패킷 교환 방식을 사용
- 3-way handshake 과정을 통해 연결을 설정하고 4-way handshake를 통해 연결을 해제
- 흐름 제어, 혼잡 제어, 오류 제어를 통해 신뢰성 있는 데이터 전송 보장
- UDP 보다 속도는 느리다

### **흐름 제어**

- 송신자의 전송 속도와 수신자의 처리 속도의 차이에서 생기는 문제를 해결하기 위한 기능
- 송신자가 데이터를 전송하는 속도가 수신자가 처리하는 속도보다 빠를 때
- 송신자가 데이터를 전송하는 속도가 너무 빠르면 수신자의 버퍼에 미처 처리하지 못한 데이터가 가득 쌓이게 되고 버퍼가 가득 차 있을 때 전송된 데이터를 소실됨
- Stop and Wait 와 Sliding Window 방식이 존재
    - Stop and Wait : 송신자가 데이터를 보낼 때마다 대기
    - Sliding Window : 한 번에 여러 개의 데이터를 보내고 수신자의 응답 기다림

### **혼잡 제어**

- 송신자의 전송 속도와 네트워크의 처리 속도 차이로 인한 문제를 해결하기 위한 기능
- 라우터가 데이터를 처리하는 속도보다 많은 양의 데이터가 들어와 네트워크 상에서 송신자가 보낸 데이터를 수신자에게 보내지 못하는 경우
- 혼잡 제어는 네트워크에 전송되는 데이터가 과도하게 증가하는 현상 방지
- AIMD(Additive Increase / Multiplicative Decrease) : 처음에 조금씩 패킷을 보내다가 패킷이 문제 없이 도착하면 전송량을 늘리는 방식 / 만약 전송에 실패하면 패킷 전송 속도를 절반으로 줄임

### **에러 제어/오류 제어**

- 데이터가 유실되거나 잘못된 데이터가 전송되었을 경우
- TCP 는 통신 중 오류가 발생하면 해당 데이터를 재전송하는 재전송 기반 오류 제어(ARQ; Automatic Repeat Request) 사용
- 송신 측이 ACK를 받지 못하거나 중복된 ACK 를 받게 되는 경우
- Stop and Wait, Go Back N, Selective Repeat 등의 방식
    - Stop and Wait : ACK 받은 후 다음 데이터를 보내는 방식으로 만약 받지 못하면 일정 timeout 이 지난 후 재전송한다
    - Go Back N : 오류가 발생한 지점부터 재전송
    - Selective Repeat : 오류가 발생한 데이터만 재전송

## UDP (User Datagram Protocol)

- 비연결형 방식으로 데이터그램 방식을 제공
    - 데이터그램 단위로 전송되며 크기는 65535바이트
- 정보를 주고 받을 때 연결 등의 절차를 거치지 않음
- UDP 헤더의 CheckSum 필드를 통해 최소한의 오류만 검출
- 신뢰성은 낮으나 TCP 보다 속도가 빠름
- 실시간 서비스(streaming)에 적합

---

# IP

## IP 주소 

인터넷에 연결된 각 기기를 구별하기 위해 사용되는 고유한 번호이다. IP는 프로토콜이고 IP주소는 IP통신을 하기 위해 기기들을 구분하는 고유 번호이다. IP 주소는 네트워크 내에서 특정 기기를 찾아 데이터를 전송할 수 있도록 도와주며 기기들이 서로 통신할 때 필수적이다. IPv4와 IPv6 두 가지 버전이 존재한다.

---

# REST API

## REST

**HTTP 통신에서 어떤 자원에 대한 CRUD 요청을 리소스와 메서드로 표현하여 특정한 형태로 전달하는 방식**

요청을 위한 URI 에 대해 GET, POST 와 같은 메서드를 통해 JSON 과 같은 특정한 형태를 사용하여 표현이 명확해지게 하는 것을 REST 라고 하며 이러한 규칙을 지켜 설계된 API RESTful API 라고 한다. 

### REST 구성요소

- Resource = URI
- Method : 서버에 요청을 보내는 방식으로 GET, POST, PUT, PATCH, DELETE
- Representation of Resouce : JSON, XML

### REST의 조건

- 일관된 인터페이스
    - URI에 대한 요청을 통일되고 한정적으로 수행하는 아키텍처 스타일. 클라이언트가 특정 플랫폼이나 언어, 기술에 종속받지 않는 것을 의미.
    - HTTP를 사용하는 몯느 플랫폼에서 요청가능하고 Loosely Coupling(느슨한 결합)형태를 갖추게 됨
- 무상태성
    - 작업의 상태 정보를 저장하지 않기 때문에 서비스의 자유도가 높고 확장성이 좋다.
    - 서버의 처리 방식에 일관성을 부여하고 서버의 부담을 줄일 수 있다.
- 캐시 가능
- 서버-클라이언트 구조
    - 자원을 가지고 있는 쪽이 서버, 자원을 요청하는 쪽이 클라이언트
- 자체 표현(Self-Descriptiveness)
    - 해당 메시지가 표현하고자 하는 내용을 쉽게 이해할 수 있도록 자체 표현하는 구조
- 계층 구조

---

# URI vs URL vs URN 

## URI (Uniform Resource Identifier) 

- 통합 자원 식별자
- 웹 상의 자원을 고유하게 식별할 수 있는 식별자
- URI 의 하위 개념으로 URL 과 URN 이 존재

## URL (Uniform Resource Locator)

- 웹 상에 존재하는 자원의 고유한 위치를 나타내는 식별자

**URL 구성 요소**

![URL](https://developer.mozilla.org/ko/docs/Learn/Common_questions/Web_mechanics/What_is_a_URL/mdn-url-all.png)

- 스키마 (Scheme) : 일반적으로 자원 요청하는데 사용되는 프로토콜
- 도메인 주소 (Domain Name) : IP 주소도 사용 가능. 호스트 주소.
- 포트 번호 : http의 경우 80, https의 경우 443
- 리소스 경로 (path)
- 매개변수 (query parameter)

## URN (Uniform Resouce Name)

- 자원의 위치와 무관한 자원의 이름
- 자원이 무엇인지 영구적이고 유일하게 식별할 수 있는 고유한 이름
---

https://yozm.wishket.com/magazine/detail/1852/

https://mangkyu.tistory.com/98

[https://inpa.tistory.com/entry/WEB-🌐-HTTP-20-통신-기술-이제는-확실히-이해하자](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-HTTP-20-%ED%86%B5%EC%8B%A0-%EA%B8%B0%EC%88%A0-%EC%9D%B4%EC%A0%9C%EB%8A%94-%ED%99%95%EC%8B%A4%ED%9E%88-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90)
