# 커널

운영체제의 핵심 부분으로 항상 메모리에 적재되어 있다. 하드웨어와 응용 프로그램 사이에서 인터페이스를 제공하는 역할을 하며 컴퓨터 자원들을 관리한다. 

# 프로세스 스레드

## 프로세스

운영체제로부터 자원을 할당 받는 작업의 단위이다. 디스크에 설치된 프로그램에 OS로부터 독립된 메모리 공간을 할당 받고 프로세스 제어 블록이 생성되며 CPU를 할당받을 수 있는 동적인 상태를 가리켜 프로세스라고 한다. 프로세스의 메모리 공간은 코드, 스택, 힙, 데이터 4가지 영역을 구분할 수 있다. 

## 스레드 

프로세스 내부의 실행 단위로 각 프로세스는 반드시 하나의 스레드를 가진다. 프로세스의 4가지 영역 중 스택을 제외한 영역을 스레드들끼리 공유하게 된다. 스레드는 스택 영역은 독립적으로 가지게 된다. 

## 프로세스 상태 변화

<img width="801" alt="Screenshot%202024-02-05%20at%202 00 33%E2%80%AFPM" src="https://github.com/simol-study/cs/assets/97926368/f2d3c8c9-4a2f-4cbb-8004-3de99c9f6ca9">

## 컨텍스트 스위칭 (Context Switching)

인터럽트나 시스템 콜에 의해 현재 실행 중인 프로세스의 제어를 다른 프로세스로 넘기는 것. 이를 위해서 기존에 실행중이던 프로세스의 정보를 프로세스 제어 블록(PCB)에 저장하고 새롭게 실행할 프로세스의 정보를 해당 프로세스 제어 블록에서 읽어들여 CPU에 적재하는 과정이 발생한다.

## 프로세스 제어 블록 (PCG; Process Control Block)

![image](https://github.com/simol-study/cs/assets/97926368/b7208541-0827-4b2c-98f8-cac9c7945e62)

OS에서 프로세스를 제어하고 관리하기 위해 프로세스 상태 정보를 저장한 데이터 구조이다. 프로세스 식별자, 프로세스 상태, 프로그램 카운터 등으로 구성된다. 프로세스를 생성할 때 만들어지고 메인 메모리에 유지되며 프로세스의 실행이 종료됨과 동시에 프로세스 제어 블록도 삭제 된다. 

### 프로세스 제어 블록의 구성

1. 프로세스 식별자 : 각 프로세스의 고유한 ID
2. 프로세스 상태 : 생성, 준비, 실행, 대기, 종료 등의 상태 표시
3. 프로그램 카운터 : 프로세스 실행을 위한 다음 명령어의 주소
4. 포인터 : 프로세스의 현재 위치
5. 레지스터 : 누산기, 베이스, 레지스터 및 범용 레지스터를 포함하는 CPU 레지스터 정보
6. 메모리 제한 : 운영 체제에서 사용하는 메모리 관리 시스템에 대한 정보

## IPC (Inter-Process Communication)

하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신이다. 프로세스는 독립된 메모리 공간을 사용하기 때문에 서로 간의 직접적인 통신에는 어려움이 있다. 이를 해결하기 위해 커널 영역(kernel-mode)에서 IPC 라는 기술을 제공여 프로세스 간 통신을 가능하게 한다. 크게 메시지 전달과 공유 메모리를 사용하는 방식으로 나눌 수 있다. 메시지 전달 방식은 커널을 통해 메시지를 전달하는 방식으로 동기화가 되어 있지만 잦은 시스템 콜로 오버헤드가 발생할 수 있다. 공유 메모리 방식은 프로세스 간에 메모리 영역을 공유할 수 있도록 허용하여 통신하는 방식으로 동시에 접근하는 동기화 문제가 발생할 수 있지만 별다른 시스템 콜 없이 직접 접근할 수 있기 때문에 빠르게 동작할 수 있다는 장점이 있다. 

### IPC 종류 

- 파이프 (Pipe) : 선입선출 형태의 파이프를 통해 두 프로세스를 연결하여 하나의 프로세스가 파이프를 통해 다른 프로세스로 데이터를 직접 전달하게 되는 방식. 기본적으로 하나의 프로세스가 파이프를 사용중이라면 다른 프로세스는 접근 할 수 없다.
- 시그널 (Singal) : 프로세스 ID 를 통해 특정 프로세스에 메시지 전달하는 방식
- 소켓 : 네트워크 상에서 프로세스 간 통신하는 방식
- 메시지 큐 : 고정 크기의 메시지를 연결 리스트를 통해 통신하는 방식. 메시지 단위로 이뤄지고 메시지 큐 ID 를 사용하여 통신하게 된다. 여러 개의 프로세스가 동시에 데이터를 다룰 수 있다. 
  ![image](https://github.com/simol-study/cs/assets/97926368/65f40686-8bd4-4a24-8ef3-6745c226fe92)

## 뮤텍스(Mutex)와 세마포어(Semaphore)

뮤텍스와 세마포어는 여러 프로세스/스레드가 동시에 공유된 자원에 접근하는 것을 막는 상호 배제 기법이다. 뮤텍스는 하나의 프로세만 하나의 자원을 공유할 수 있도록 키를 기반으로 하는 기법이다. 해당 키를 보유한 프로세스만 공유 자원이 접근할 수 있고, 해당 프로세스만이 접근 제한을 해제할 수 있다. 세마포어는 공통으로 관리되는 하나의 값을 통해 상호 배제를 달성하는 기법으로 여러 프로세스가 자원에 동시에 접근할 수 있고 반드시 lock을 획득한 프로세스가 아니더라도 lock을 해제할 수 있다. 

# Blocking or Non-Blocking, Synchronous and Asynchronous

- Synchronous : 요청한 작업이 순차적으로 진행되는 것을 보장하는 방식으로 하나의 작업이 종료되어야 다른 작업이 시작될 수 있다.
  ![image](https://github.com/simol-study/cs/assets/97926368/b12de51d-000e-4ea7-bd0c-018181c423a5)
- Asynchronous : 각 작업들이 다른 작업의 종료 여부와는 상관없이 시작될 수 있는 방식이다. 
  ![image](https://github.com/simol-study/cs/assets/97926368/70c377a0-39ec-44d5-b259-0f3095dcd399)

- Blocking : 작업 수행 중 다른 작업을 호출했을 때 다른 작업의 결과를 기다리며 해당 작업이 동작하지 않고 대기하고 있는 방식
  <img width="485" alt="image" src="https://github.com/simol-study/cs/assets/97926368/2fb20abf-c294-4f14-81d6-a63319c48423">
- Non-Blocking : 작업 실행 중 요청한 다른 작업이 종료되지 않아도 곧바로 해당 작업을 계속 수행하는 방식
  ![image](https://github.com/simol-study/cs/assets/97926368/83d77de9-d493-4411-8547-f13ae8e257d3)

## 4가지 케이스 예시 

![image](https://github.com/simol-study/cs/assets/97926368/70b858f8-38a1-4d1c-add7-8acd91b3604d)

- Sync + Blocking IO : 가장 많이 사용되는 IO 방식으로 일반적으로 시스템 콜을 통해 IO가 실행될 때 해당 방식을 사용하게 된다. 
  ![image](https://github.com/simol-study/cs/assets/97926368/870dcb25-5a1a-4a78-b9b7-c603d720255a)
- Sync + Non-Blocking IO : 
- Async + Blocking IO : 

# CPU 스케줄링

- 비선점형 스케줄링 : 프로세스로부터 운영체제가 강제로 CPU를 빼앗을 수 없는 스케줄링 방식
  - FCFS : First-Come-First-Served
  - SJF : 작업 시간이 짧은 프로세스에 먼저 CPU 할당하는 방식
  - HRN : 우선순위가 높은 순서대로 할당하는 방식

- 선점형 스케줄링 : 운영체제가 프로세스로부터 강제로 CPU를 빼앗을 수 있는 방식
  - RR(Round-Robin) : 대기 큐에 먼저 도착한 프로세스부터 CPU를 할당하고(FCFS) 대신 CPU를 사용할 수 있는 시간(quantum)을 정해두는 방식
  - 다단계 큐 : 다중 큐를 사용하는 방식으로 큐 간의 이동이 불가능하고 상위 큐가 비어 있을 때 하위 큐가 CPU를 할당 받을 수 있는 방식
  - 다단계 피드백 큐 : 다단계 큐를 보완하기 위한 방식으로 우선순위가 다중 큐를 사용하지만 각 큐마다 CPU를 할당받아 사용할 수 있는 시간을 정해두는 방식이다. 하위 큐로 내려갈수록 해당 시간이 길어져 FCFS에 가깝게 된다. 

## 콘보이 현상 (Convoy Effect)

작업 시간이 긴 프로세스가 먼저 CPU를 할당받아 다른 프로세스의 실행 시간이 전부 늦춰지는 비효율적인 현상이다. FCFS 스케줄링의 경우 발생할 수 있다. 

## 에이징 (Aging)

대기 큐에서 프로세스가 너무 오래 대기하게 되는 경우 대기 시간이 지날수록 우선순위를 높여주는 방식이다. 

# 데드락 (DeadLock)

다른 프로세스가 점유 하고 있는 자원을 서로 기다리며 둘 이상의 프로세스가 무한 대기 상태에 빠지게 되는 상황을 의미한다. 데드락의 발생 조건으로는 상호 배제, 점유 대기, 비선점, 순환 대기가 있다. 
  - 상호 배제 (Mutual Exclusion) : 한 번에 하나의 프로세스만 자원에 접근할 수 있다.
  - 점유 대기 (Hold & Wait) : 자원을 최소한 하나 보유한 상태에서 다른 프로세스에 할당된 자원을 점유하기 위해 대기하고 있는 프로세스가 존재해야 한다.
  - 비선점 (Nonpreemptive) : 다른 프로세스에 할당된 자원은 강제로 빼앗을 수 없다.
  - 순환 대기 (Circular Wait) : 두 개 이상의 프로세스가 대기 중인 관계가 순환 구조이다. 

# 가상 메모리 

메모리 관리 기법의 하나로 실제 사용되는 메모리를 추상화하여, 물리 메모리의 크기가 서로 다른 경우에도 프로세스들이 일관되게 실행될 수 있도록 하는 기술이다. 가상 메모리를 사용함으로써 메모리에 대한 의존성을 낮출 수 있고, 메모리보다 큰 크기의 프로세스를 실행할 수 있으며, 메모리에 직접 접근하는 것을 제어할 수 있어 보안에 용이하다는 장점이 있다. 

# 페이지 교체

프로그램이 실행될 때 메모리에 모든 영역이 적재되어 있지 않고 페이지 단위로 일부만 메모리에 올라와 있기 때문에 요청한 작업이 메모리에 적재되어 있지 않을 수 있다. 이것을 필요한 메모리가 부재한 상태(page fault)라고 하며 해당 작업을 위한 페이지를 가져와야 한다. 이때 물리 메모리가 모두 사용중이라면 페이지 교체가 이루어지게 된다. 

## 페이지 교체 알고리즘

- FIFO : 선입선출 방식으로 물리 메모리에 올라온지 가장 오래된 페이지를 먼저 내보내는 방식이다
- 최적 페이지 교체 (Optimal Page Replacement) : 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아서 교체하는 방식이나 프로세스가 앞으로 어떤 페이지가 사용될 지 예측하는 것이 불가능하므로 실제 구현에서 사용되지는 않는다.
- LRU (Last-Recentlly-Used) : 가장 오랫동안 사용되지 않은 페이지를 교체
- LFU (Least-Frequently-Used) : 참조 횟수가 가장 적은 페이지를 선택해서 교체
- MFU (Most-Frequently-Used) : 참조 횟수가 가장 많은 페이지 교체

## 내부 단편화와 외부 단편화

- 내부 단편화 : 프로세스가 필요로 하는 메모리 공간보다 더 큰 메모리가 할당되어서 내부 메모리 공간이 낭비되는 현상
- 외부 단편화 : 남아 있는 메모리 공간이 필요한 프로세스의 메모리 공간보다 크지만 연속적이지 않아 발생하게 되는 현상

## 페이징 기법

비연속적인 메모리 할당 기법 중 하나로 연속적으로 메모리를 할당한 경우 메모리에 남은 공간들이 흩어진 채로 존재하여 외부 단편화 현상이 발생하게 된다. 이를 해결하기 위해 프로세스를 페이지 단위로 나누고 메모리도 프레임 단위로 나눠 관리하여 외부 단편화 문제를 해결할 수 있다. 


## 출처

- Blocking : https://interconnection.tistory.com/141
