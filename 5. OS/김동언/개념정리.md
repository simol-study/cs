# 운영체제 
## 개념정리 

----

### 운영체제
운영체제 OS Operating System 

운영체제란 컴퓨터 시스템과 사용자와의 인터페이스를 제공하는 소프트웨어 입니다.

운영체제는 컴퓨터 자원을 효율적으로 관리하고 다양한 기능을 수행합니다.
- 프로세스 관리
- 메모리 관리
- 파일 시스템 관리
- 입출력 관리 등..

운영체제의 대표적인 예로는 Windows, Mac OS, Linux, IOS 등이 있습니다.



### 시스템 콜
시스템 콜, System call

시스템 콜이란 사용자 프로그램이 운영체제의 커널에 접근하기 위한 인터페이스 입니다.

시스템 콜을 통해 사용자 프로그램은 운영체제가 관리하는 하드웨어, 소프트웨어 리소스에 안전하게 접근할 수 있습니다.

프로그램이 직접 하드웨어에 접근하는 것을 제한하는 것으로 시스템의 전반적인 안정성과 보안을 보장하는데 도움을 줍니다.


### 커널
커널, Kernel

커널이란 하드웨어와 소프트웨어 사이의 인터페이스를 제공하는 소프트웨어 입니다.

커널은 운영체제 중 항상 메모리에 올라가 있으며 컴퓨터 자원(CPU, 메모리 등)을 관리합니다.

커널은 보통 프로그램이 하드웨어에 직접 접근하는 것을 제한하고 자신을 통해 하드웨어와 통신하게 합니다.

이를 통해 시스템의 안정성과 보안을 유지합니다.

커널은 항상 컴퓨터 자원을 바라보기 때문에 사용자와 상호작용하지 않습니다.

상호자와 직접적인 상호작용을 위해 프로그램을 사용하는데 대표적인 예시 shell 명령어 해석기 등이 있습니다.


### CPU
CPU, Central Processing Unit, 중앙 처리 장치 

컴퓨터 두뇌 역할을 하는 핵심 하드웨어 부품입니다.

컴퓨터 프로그램의 명령을 실행하고 처리하는 기능을 담당합니다.

CPU는 ALU(산술 논리 연산 장치), 레지스터, 제어 장치로 이루어져 있습니다.

ALU : 연산(수학적 연산, 논리 연산) 수행한다. 기본적인 데이터 처리 작업을 담당한다.

제어 장치 : CPU내의 다른 부품들을 조정하고 제어하는 역할을 한다. 메모리에서 명령을 가져오고, 해석하며 필요한 연산을 ALU에서 실행하도록합니다. 명령어 실행 순서를 관리하고 데이터 흐름을 제어한다.

레지스터 : CPU 내부의 빠른 메모리로 현재 진행 중인 연산에 필요한 데이터와 명령어, 연산 결과를 임시로 저장한다. 레지스터는 소량의 데이터를매우 빠르게 액세스하여 CPU의 연산 속돌르 크게 향상시킵니다.

CPU의 성능은 초당 수행할 수 있는 명령어의 수(클럭 속도)와 같은 여러 요소에 의해 결정됩니다.

CPU는 멀티코어 설계를 통해 동시에 여러 작업을 처리할 수 있다.

### CPU 스케쥴링

CPU 스케쥴링이란 여러 프로세스나 스레드 중에 어떤 것을 CPU에 할당할지를 결정하는 작업 입니다.

CPU 스케쥴링 알고리즘을 통해 다음에 할당할 것을 선택합니다.

CPU 스케쥴링을 사용하면 CPU를 효율적으로 사용할 수 있어 성능이 높아집니다.


### CPU 스케쥴링 알고리즘 
스케줄링 알고리즘은 비선점형과 선점형이 있습니다.

비선점형은 한 번 CPU를 사용하고 있는 프로세스는 다른 프로세스에게 뺏기지 않습니다.

선점형은 프로세스가 CPU를 사용하고 있어도 다른 프로세스에게 뺏길 수 있습니다.

비선점형 알고리즘의 종류들은 다음과 같습니다.

선입선출(FCFS, First Come First Serve) : 가장 먼저 CPU를 요청한 프로세스에게 CPU를 할당합니다.

최단 작업 우선(SJF, Shortest Job First) : CPU를 사용할 시간이 가장 짧은 프로세스에게 CPU 할당합니다.

우선순위 스케줄링(Priority Scheduling) : 각 프로세스의 우선순위를 부여하고 가장 높은 순서대로 CPU 할당합니다.

선점형 알고리즘의 종류들은 다음과 같습니다.

라운드 로빈(RR, Round Robin) : 각 프로세스에게 동일한 시간 할당량을 부여하고 이 시간동안만 CPU를 사용합니다. 시간 할당량이 끝나면 다음 프로세스에게 CPU를 넘깁니다.

최단 남은 시간 우선(SRTF, Shortest Remaining Time First) : 남은 실행 시간이 가장 짧은 프로세스에게 CPU를 할당합니다.

선점형 우선순위 스케줄링(Priority Scheduling with preemption) : 우선순위가 더 높은 프로세스가 도착하면 현재 실행 중인 프로세스를 중단하고 새로운 프로세스에게 CPU를 할당합니다.

상황에 맞게 적절한 알고리즘을 선택하여 CPU를 효율적으로 사용합니다.


### 인터럽트
인터럽트, Interrupt

인터럽트란 어떤 신호가 들어와  CPU를 잠깐 정지시키고 다른 작업을 수행하는 것입니다.

인터럽트의 발생 원인은 하드웨어, 소프트웨어 2가지 유형이 있습니다.

하드웨어(외부) 인터럽트

- IO 디바이스에 의해 발생
- 예시 - 마우스 클릭, 키보드 입력, 외부 장치 연결 등

소프트웨어(내부) 인터럽트

- 프로세스의 예외 상황이나 프로그램이 필요한 특정 서비스를 호출할 때 발생
- 예시 - 0으로 나누는 오류, 시스템 콜 호출 등

인터럽트 과정

인터럽트 발생 → 인터럽트 인식 → 인터럽트 처리 → 작업 복귀


### 메모리
메모리, Memory
메모리는 데이터, 상태, 명령어 등을 저장하는 장치입니다.

메모리라 하면 주로 RAM을 일컬습니다.

레지스터, 캐시, 메모리(RAM), 저장장치(디스크)

메모리 계층은 크게 레지스터, 캐시, 메모리, 저장장치로 이루어져 있습니다.

용량이 적음, 가격 비쌈, 성능 좋음 ↔ 용량 큼, 가격 저려함, 성능 부족함


### 가상 메모리 
가상 메모리란 메모리가 실제 메모리 보다 더 많아 보이게 하는 기술 입니다.

프로세스가 실행될 때 메모리에 해당 프로세스 전체가 올라가지 않아도 실행이 가능하다는 것을 이용한 기법입니다. 프로세스가 실행될 때, 실행에 필요한 부분을 메모리(RAM)에 올리고 나머지는 디스크에 둡니다.

즉, 빠르고 작은 기억 장치(RAM)과 크고 느린 기억 장치(디스크)와 병합하여 하나의 크고 빠른 기억 장치(가상 메모리)처럼 동작하게 합니다. 디스크에는 스왑 공간(swap space)를 사용합니다.

가상 메모리 구현 방법이 요구 페이지이다.

가상 메모리의 핵심 개념 중 하나는 페이징 입니다.

프로세스의 가상 메모리는 여러 개의 작은 블록, 즉 페이지로 나누어 집니다.

이 페이즈들은 필요에 따라 RAM과 스왑 공간 사이를 이동합니다.

프로세스가 실행되면 특정 페이지에 접근할 때 운영체제는 해당 페이지가 RAM에 있는지 확인하고 필요하면 스왑 공간에서  RAM으로 이동시킵니다. 이러한 과정을 페이지 폴트와 스와핑이라 합니다.

페이지 폴트 :

특정 페이지에 접근하려 할 때 그 페이지가 RAM에 없을 때 페이지 스왑 공간에 필요한 페이지를 RAM으로 로드하는 것 입니다.

스와핑 :

RAM이 가득찬 상태에서 페이지 폴트가 발생하면 운영체제는 RAM에서 페이지 하나를 선택해 스왑 공간의 페이지와 바꾸는 작업을 수행합니다.


### 캐시
캐시, Cache

캐시는 데이터를 미리 복사해 놓은 임시 저장소입니다.

캐시는 빠른 장치와 느린 장치에 속도 차이에 따른 병목 현상을 줄이기 위해 사용됩니다.

캐시를 사용하면 데이터에 접근하는 시간을 줄이고 다시 계산하는 시간을 절약할 수 있어 성능이 올라갑니다.


### 캐시히트와 캐시미스
Cache hit, Cache miss
캐시히트란 캐시에서 원하는 데이터를 찾은 것입니다.

캐시미스는 원하는 데이터가 캐시에 없어 주 메모리로 가서 데이터를 찾는 것 입니다.


### 웹 브라우저의 캐시 종류
웹 브라우저의 캐시로는 쿠키, 로컬 스토리지, 세션 스토리지가 있습니다.

웹 브라우저의 캐시들은 사용자 정보나 인증 모듈 관련 사항들을 저장합니다.

이후 서버에 요청할 때 자신을 나타내는 아이덴티나 중복 요청 방지를 위해 사용됩니다.

쿠키

- 키-값 형태의 저장소
- 만료기한이 있음
- 4KB까지 데이터 저장

로컬 스토리지

- 키-값 형태의 저장소
- 만료기한이 없다.
- 10MB까지 데이터 저장
- 웹 브라우저를 닫아도 유지

세션 스토리지

- 키-값 저장소
- 탭 단위로 세션 스토리지 생성한다. 탭을 닫을 때 해당 데이터가 삭제된다.
- 5MB까지 저장


### 프로세스
프로세스, Process 

프로세스란 실행 중인 컴퓨터 프로그램입니다.

하드디스크 있는 프로그램을 실행하면 메모리에 할당되어 적재됩니다.

이 순간부터 프로세스라 불립니다.

프로세스는 자신만의 메모리를 가지며 독립적으로 실행됩니다.

독립적으로 실행되어 다른 프로세스에게 영향을 주지 않아 안정성이 보장됩니다.

프로세스는 여러 개의 작업을 병렬로 수행할 수 있습니다.

시스템의 성능과 처리량이 크게 향상됩니다.


### 프로세스 통신 IPC 
프로세스 통신, IPC, Inter-Process Communication 

IPC(Inter Process Communication)

IPC는 프로세스 간 통신 방법입니다.

프로세스가 통신 가능하다는 것은 서로 다른 프로세스가 데이터를 주고 받을 수 있다는 것이 동시에 접근 가능한 메모리 즉 프로세스들이 공유하는 메모리가 필요하다는 뜻 이다.

스레드는 메모리 공간과 자원을 공유하여 비교적 쉽게 통신할 수 있다.

반면, 프로세스는 통신할 수 없는 공간이 없기 때문에 통신을 위한 별도의 공간을 만들어줘야 한다.

커널 영역에서 IPC 라는 내부 프로세스간 통신을 제공하고 프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스간 통신을 할 수 있게 된다.



### IPC 종류 

공유 메모리 (Shared Memory)

공유 메모리가 데이터 자체를 공유하도록 지원하는 설비, 프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용한다.

프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당한다. 이후 어떤 프로세스건 해당 메모리 영역에 접근할 수 있다.

공유 메모리가 각 프로세스에게 첨부하는 방식으로 작동한다.

프로세스간 Read, Write 모두 필요할 때 사용한다.

대량의 정보를 다수의 프로세스에게 배포 가능하다.

중개자 없이 곧바로 메모리에 접근할 수 있어 모든 IPC 중 가장 빠르게 작동한다.

파이프

통신을 위한 메모리 공간(버퍼)을 생성하여 프로세스가 데이터를 주고 받을 수 있게 한다.

익명 파이프

- 일반적인 파이프
- 통신할 프로세스가 명확하게 알 수 있는 경우 사용
- 외부 프로세스가 사용할 수 없음
- 파이프는 2개의 프로세스를 연결. 하나의 프로세스는 쓰기만 할 수 있고 하나의 프로세스는 읽기만 할 수 있다. 단방향 통신
- 송수신을 모두 원하면 두 개의 파이프를 만들어야 한다.

네임드 파이프

- 전혀 모르는 상태의 프로세스들 사이의 통신에 사용
- 익명 파이프의 확장된 상태.
- 프로세스 통신을 위해 이름 있는 파일을 사용
- FIFO 라 불리는 특수 파일을 이용해 서로 관련 없는 프로세스간 통신에 사용
- 외부 프로세스 통신 가능

소켓 (Socket)

동일한 호스트 운영체제에서 실행되는 프로세스간 데이터를 교환하기 위한 데이터 통신 엔드 포인트이다.

- 네트워크 소켓 통신을 통해 데이터를 공유
- 양쪽 PC에 임의의 포트를 설정
- 각각의 PC에서 프로세스를 통해 PC PORT에 연결하라는 명령을 보내면 두 프로세스는 확인 과정을 거쳐 연결을 진행한다. 연결하면 파이프와 같이 1대 1로 데이터를 주고받는 방식이다.
- 클라이언트와 서버가 소켓을 통해서 통신하는 구조로 원격에서 프로세스 간 데이터 공유를 사용
- 양방향 통신이 가능
- 서버, 클라이언트 환경을 구축하는데 용이

메세지 큐 (Message Queue)

입출력 방식은 네임드 파이프와 동일하다.

메세지 큐는 파이프처럼 데이터의 흐름이 아니라 메모리 공간이다.

다수의 프로세스간 메세지를 전달 할 수 있다.

사용할 데이터 번호를 붙이면 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있다.

메시지의 접근을 위해 키가 필요하다.

메모리 맵 (Memory Map)

공유 메모리처럼 메모리를 공유한다.

메모리 맵은 열린 파일을 메모리에 맵핑시켜서 공유하는 방식이다.

주로 파일로 대용량 데이터를 공유할 때 사용한다.

FILE IO가 느릴 떄 사용하면 좋다.

대부분 운영 체제에서 프로세스를 실행할 때 실행 파일의 각 세그먼트를 메모리에 사상하기 위해 메모리 앱 파일을 이용한다.

메모리 맵 파일은 파일의 크기를 바꿀 수 없으며 메모리 맵 파일을 사용하기 이전, 이후만 파일의 크기를 바꿀 수 있다.

RPC (Remote Procedure Call)

RPC는 분산 네트워크 망에서 많이 사용되는 방식

별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게하는 프로세스 간 통신 기술이다. 원격 프로시저 호출을 이용해 프로그래머는 함수가 실행 프로그램에 로컬 위치에 있뜬 원격 위치에 있든 동일한 코드를 이용할 수 있다.

분리된 PC에 저장된 데이터를 마치 내 PC에 존재하는 것처럼 데이터를 가져와 사용하는 방법이다.

출저 : https://dar0m.tistory.com/233


### PCB 
PCB, Process Control Block

PCB란 프로세스의 메타데이터입니다. (메타데이터 : 데이터를 설명하는 데이터)

PCB에는 프로세스 ID, 권한, 스케쥴링 상태 등 프로세스에 관한 데이터를 저장합니다.

컨텍스트 스위칭 할 때 PCB를 이용해 프로세스의 현재 상태를 저장하거나 불러옵니다.



### 프로세스 메모리 구조 

프로세스 간에는 이 메모리 영역에 간섭할 수 없습니다.

프로세스는 각각의 독립된 메모리 영역을 가지고 있습니다.

프로세스 메모리는 Code, BSS, Data, Heap, Stack 영역으로 이루어져 있습니다.

Code 영역

- 프로그램을 실행시키는 명령어들이 저장되는 영역 (소스코드)
- 프로그램이 실행될 떄 CPU는 코드 영역에 저장된 명령어를 하나씩 처리
- 일반적으로 읽기 전용으로 프로세스의 코드는 런타임에 변경되지 않음

BSS  영역

- 초기화 되지 않은 전역변수와 정적변수가  저장되는 영역
- 기본적으로 0으로 초기화하고 메모리 효율성을 높입니다.

Data 영역 (Java의 메소드 영역과 비슷 )

- 전역 변수와 정적 변수가 저장되는 영역
- 프로그램 시작과 함께 할당되고 종료할 때 소멸된다.

Heap 영역

- 메모리를 동적으로 할당 받은 데이터들이 저장되는 영역
- 필요에 따라 메모리 크기를 늘리거나 줄일 수 있다.
- 값이 작은 주소값에서 큰 주소값 순서로 사용

Stack 영역

- 지역 변수, 함수 호출 시 파라미터를 저장하는 영역
- 함수 호출 시 사용되고 종료되면 제거된다.
- 값이 큰 주소값에서 작은 주소값 순서로 사용


### 프로세스 스케쥴링

프로세스 스케쥴링이란 CPU가 어떤 프로세스를 실행할지 결정하는 것입니다.

CPU의 할당 방법은 스케줄링 알고리즘을 통해서 정합니다.

대부분의 OS는 우선순위 알고리즘과 라운드 로빈 알고리즘을 혼합해서 스케줄링 합니다.

프로세스 스케줄링는 CPU 작업을 최적으로 분배해 시스템 성능을 최적화하는 역할을 합니다.


### 프로세스 상태 변화 

프로세스 상태 변환이란 프로세스가 실행되는 동안 겪는 여러 상태를 나타내는 것 입니다.

프로세스는 생성, 대기, 실행, 대기 종료의 상태를 갖습니다.

생성 : 프로세스가 생성되어 시스템에 추가되지만 아직 메모리에 로드되지 않은 상태 입니다.

대기 : 프로세스가 메모리에 로드되어 실행을 위해 CPU 할당을 기다리는 상태 입니다.

실행 : 프로세스가 CPU를 할당받아 명령어를 실행하는 상태 입니다.

대기 : 프로세스가 입출력 작업이나 특정 이벤트의 완료를 기다리는 상태 입니다.

종료 : 프로세스가 작업을 완료하고 시스템에서 제거된 상태 입니다.

프로세스는 이러한 상태들을 오가며 수행되고 운영체제의 스케줄러에 의해 관리됩니다.

프로세스 상태변화를 통해 시스템의 자원을 효율적으로 활용하고 여러 프로세스를 동시에 처리할 수 있습니다.

(CPU는 하나의 프로세스만 실행된다. 그러나 운영체제가 매우 빠른 속도로 여러 프로세스를 전환함으로써 동시에 여러 프로세스가 실행되는 것 처럼 보인다. 이를 멀티태스킹이라고 부릅니다.)



### 스레드 
스레드, Thread 

스레드란 프로세스 내부의 작업 흐름 입니다.

한 프로세스에는 적어도 하나 이상의 스레드가 존재합니다.

프로세스 내에 스레드들은 Code, Data, File 같은 메모리 공간(시스템 자원들)을 공유합니다.

이러한 공유는 커널의 개입 없이 스레드간의 통신을 가능하게 합니다.

스레드 생성과 동기화 비용을 줄여줍니다.

문맥전환(Context Switching)에 따른 오버헤드와 소요되는 시간을 줄여줍니다.

하지만 스레드가 자원을 공유하기 때문에 동기화 문제가 발생할 수 있습니다.

(동기화 문제 - 두 스레드가 동시에 같은 메모리를 수정하려 하는 것)

이러한 문제를 방지하기 위해 동기화 메커니즘인 뮤택스, 세마포어 등을 사용합니다.


### 멀티 프로세스와 멀티 스레드

멀티 프로세스란 여러 개의 프로세스를 동시에 실행한 것 입니다.

멀티 스레드란 하나의 프로세스 내에서 여러 개의 스레드를 동시에 실행한 것 입니다.

멀티 프로세스와 멀티 스레드 모두 여러 개의 실행 흐름을 통해 여러 작업들을 동시에 처리합니다.

비슷한 역할을 수행하지만 차이점 또한 명확입니다.

바로 메모리 공유 여부 입니다.

멀티 프로세스는 독립적인 메모리 공간을 가짐으로 메모리를 공유하지 않습니다.

이는 하나의 프로세스에서 오류가 발생해도 다른 프로세스에 영향을 미치지 않아 안정성이 높습니다.

하지만 프로세스를 생성하고 문맥전환(Context Switching)하는데 비용이 많이 듭니다.

또한 프로세스들은 IPC(Inter Process Communication)로 통신하는데 스레드끼리 통신보다 느립니다.

반면, 멀티 스레드는 프로세스의 메모리를 공유합니다.

이는 스레드의 생성하고 문맥전환 하는데 비용을 적게 듭니다.

또한 스레드는 공유 메모리를 통해 통신하여 IPC 보다 빠릅니다.

하지만, 스레드 간에 메모리를 공유하기 때문에 동기화 문제가 발생할 수 있습니다.


### 컨텍스트 스위칭 

컨텍스트 스위칭이란 운영체제가 CPU가 현재 실행 중인 프로세스(또는  스레드)에서 다른 프로세스(또는 스레드)로 전환하는 과정 입니다. (PCB를 교환하는 과정)

컨텍스트는 현재 실행 중인 프로세스의 상태를 나타내며 프로세스의 프로그램 카운터, 레지스터 값, 스택 정보 등을 포함합니다. 이러한 정보를 보존하여 프로세스가 중단되었을 때 나중에 이어서 작업을 계속하게 해줍니다.

프로세스가 대기상태일 때 컨텍스트 스위칭을 통해 다른 프로세스를 실행시킵니다.

이를 통해 CPU의 대기 상태를 최소화시키고 CPU 자원을 끊임없이 사용하여 효율성을 증가시킵니다.

이 작업은 빠르게 진행되어 사용자에게는 여러 프로세스를 동시에 처리하는 것 처럼 보입니다.

하지만 잦은 컨텍스트 스위칭 사용은 오버헤드를 증가시켜 성능 저하를 일으킬 수 있습니다.

즉, 오버헤드를 최소화하며 CPU를 효율적으로 사용하는 것이 스케줄러의 주된 역할 중 하나 입니다.

컨텍스트 스위칭의 진행 과정은 다음과 같습니다.

1. 현재 실행 중인 프로세스 혹은 스레드의 컨텍스트를 저장

(프로세스의 컨텍스트 정보는 PCB, 스레드의 컨텍스트 정보는 TCB에 저장합니다.)

1. 스케줄러가 다음 실행할 프로세스 혹은 스레드 결정
2. CPU가 새로운 프로세스 혹은 스레드의 컨텍스트 정보에 따라 실행 시작


### 스레싱
스레싱, Thrashing 

스레싱은 메모리 페이지의 폴트율이 높은 것을 의미하며 컴퓨터의 성능 저하를 초래하는 현상입니다. 스레싱은 메모리에 너무 많은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나서 생깁니다.

이를 해결하기 위해 메모리를 늘리거나 작업 세트와 PFF가 있습니다.

작업 세트

작업 세트는 페이지 집합을 만들어 미리 메모리에 로드하는 방법 입니다.

미리 메모리를 로드하면 탐색에 드는 비용을 줄일 수 있고 스와핑 또한 줄일 수 있습니다.

PFF

PFF는 페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만듭니다.

상한선을 넘어가면 추가 작업을 수행하여 물리적 메모리에 더 많은 페이지를 적재하고 하한선 아래로 떨어지면 추가 작업을 줄여 물리적 메모리에 적재된 페이지 수를 줄입니다.

핵심은 스와핑을 줄이는 것 입니다.


### 세마포어
세마포어, Semaphore 

세마포어란 멀티 프로그래밍 환경에서 동시성 제어를 위해 사용되는 변수 입니다.

다수의 프로세스나 스레드가 동일한 자원에 동시에 접근하는 것을 방지합니다.

세마포어는 두 가지 연산인 wait 과 signal 을 사용합니다.

wait 연산은 세마포어의 값을 감소시키고 signal 연산은 세마포어의 값을 증가시킵니다.

프로세스가 자원에 접근할 때 세마포어의 값이 음수면 양수가 될 때까지 대기합니다.

이러한 방식으로 세마포어는 여러 프로세스나 스레드의 공유 자원 동시 접근을 제어하여 경쟁 상태를 방지하므로 시스템의 동기화를 유지하는데 도움을 줍니다.


### 뮤텍스
뮤텍스, Mutex

뮤텍스란 동시성 제어를 위해 사용되는 도구 입니다.

뮤텍스는 공유 자원에 대한 동시 접근을 제어하는데 한 번에 하나의 프로세스 혹은 스레드만 접근하도록 보장합니다.

뮤텍스의 동작은 잠금과 해제가 있습니다.

잠금은 공유 자원에 락을 거는 연산 입니다. 스레드가 공유 리소스에 접근하기 전에 뮤텍스에 락을 겁니다.

뮤텍스가 락이 걸려있다면 다른 스레드는 뮤텍스가 해제될 때 까지 기다립니다.

해제는 공유 자원에 락을 푸는 연산 입니다. 스레드가 공유 자원을 사용을 완료하면 뮤텍스의 락을 풉니다.

락이 해제되면 대기 중이던 다른 스레드들이 뮤텍스의 락을 걸고 공유 자원을 사용합니다.

이런 방식으로 뮤텍스는 공유 리소스에 대한 동시 접근을 제한하고 경쟁 조건을 방지하여 동기화를 유지합니다.


### 세마포어와 뮤텍스

세마포어와 뮤텍스는 모두 동시성을 제어하여 경쟁 상태를 방지하고 동기화를 유지하는데 도움을 줍니다.

세마포어와 뮤텍스의 차이점은 동기화 대상의 갯수, 소유권 등이 있습니다.

세마포어는 공유자원에 여러 개의 프로세스 혹은 스레드가 접근하는 것을 제어 합니다.

뮤텍스는 공유자원에 하나의 프로세스 혹은 스레드가 접근하는 것을 제어 합니다.

뮤텍스는 소유권 개념을 가지고 있습니다.

뮤텍스는 잠금 상태로 만든 스레드만이 그것을 해제할 수 있습니다.

반면, 세마포어는 소유권 개념이 없기 때문에 잠금을 설정한 스레드와 다른 스레드가 잠금을 해제할 수 있습니다.

사용하려는 자원의 수, 동시 접근이 필요한 프로세스 갯수 등을 고려하여 적절한 동기화 메커니즘을 선택하는 것이 중요합니다.



### 동기와 비동기 
동기, Synchronous
비동기, Asynchronous 


동기는 순차적으로 일을 진행한다. 요청한 작업이 완료되어야 다음 일을 진행

비동기는 순차적으로 일을 진행하지 않고 요청한 작업의 완료 여부 관계 없이 다음 일을 진행

동기란 작업이 순서대로 하나씩 차례대로 이루어지는 방식 입니다. 어떤 작업이 완료될 때 까지 다음 작업은 대기하게 됩니다.

이 방식은 구현이 간단하고 직관적이지만 이전 작업이 끝나기를 기다려야 하므로 비효율적일 수 있습니다.

비동기는 순차적으로 진행하지 않고 작업의 결과를 기다리지 않고 바로 다음 작업을 진행한다.

비동기란 특정 작업의 완료 여부와 관계 없이 다음 작업을 진행하는 방식 입니다.

작업이 병렬적으로 진행됩니다.

이 방식은 자원을 효율적으로 사용하지만 작업의 순서를 제어하거나 오류를 처리하는게 복잡할 수 있습니다.



### 블로킹과 넌블로킹
블로킹, Blocking
넌블로킹, NonBlocking 

제어권을 가지고 다음 작업을 하냐 안하냐가 중요 포인트

블로킹

제어권을 가지고 있으면서 다음 작업을 대기

넌블로킹

제어권을 가지고 있으며 다음 작업을 진행할 수 있음


### 교착 상태와 해결 방법
교착 상태, Deadlock

교착 상태는 두 개 이상의 프로세스나 스레드가 서로의 작업이 끝나기를 영원히 기다리는 상황 입니다.

교착 상태는 4가지 조건이 모두 만족해야 발생합니다.

상호 배제 : 프로세스가 자원을 독점하면 다른 프로세스가 접근할 수 없다.

점유 대기 : 특정 프로세스가 점유한 자원을 다른 프로세스가 대기한다.

비선점 : 다른 프로세스가 자원을 강제로 가져올 수 없다.

환형 대기 : 프로세스가 서로의 자원을 요구하는 상황

데드락은 4가지 조건 중 하나만 이루어지지 않아도 해결됩니다.

해결 방법은 예방, 탐지 및 복구, 무시 3가지 방법이 있습니다.

예방 : 교착 상태가 되지 않도록 합니다. 자원 할당 그래프를 통해 자원을 할당했을 때 교착 상태가 되는지 체크합니다.

탐지 및 복구 : 교착 상태가 탐지되면 프로세스를 종료하여 복구 시킵니다.

무시 : 교착 상태가 드물게 발생하는 경우 해결하는 비용보다 재부팅 비용이 저렴하면 재부팅을 합니다. 대부분의 운영체제가 이 방법을 사용하고 있습니다.



