# 운영체제

<br>

## 운영체제(OS, Operating System)

운영체제란 하드웨어 위에 설치되어 하드웨어 계층과 다른 소프트웨어 계층을 연결하는 소프트웨어다. 컴퓨터 시스템의 자원을 관리하고, 사용자가 컴퓨터를 사용할 수 있는 환경을 제공하는 역할을 수행한다. 또한, 사용자와 컴퓨터 간 인터페이스를 제공해 사용자가 컴퓨터를 편리하게 사용할 수 있는 환경을 제공한다. 대표적인 OS로는 윈도우(Windows), 맥OS(macOS), 리눅스(Linux), 유닉스(Unix) 등이 있다. 

<br>
<br>

## CPU와 메모리 구조

CPU(Central Processing Unit, 중앙 처리 장치)는 ‘컴퓨터의 뇌’ 역할을 하며, 컴퓨터에서 프로그램을 실행하는 데 필요한 연산을 처리하고 수행한다. 다른 말로 프로세서(processor)라고도 한다. 

메모리는 데이터를 저장하기 위한 기억장치로, 휘발성 메모리인 주 기억장치와 비휘발성 메모리인 보조 기억장치가 있다. 주 기억장치는 메인 메모리를 의미하며 일반적으로 RAM을 가리킨다. 보조 기억장치로는 SSD(Solid State Drive), HDD(Hard Disk Drive) 등이 해당된다. 

메모리는 CPU에서 빨리 접근할 수 있도록 계층 구조로 나뉜다.

- **레지스터(register)**
    - CPU가 사용자 요청을 처리하는 데 필요한 데이터를 임시로 저장하는 기억장치.
    - CPU 내부에 존재하며 접근 속도가 빠름
- **캐시 메모리(cache memory)**
    - CPU와 RAM 사이의 속도 차이를 해결하기 위한 기억장치.
    - CPU 내부에 위치하며 접근 속도가 레지스터 다음으로 빠름
- **RAM(Random Access Memory)**
    - 컴퓨터에서 프로그램을 실행할 때 필요한 정보를 저장한다.
    - CPU에서 접근 속도가 하드 디스크보다 빠르고, 휘발성 기억장치다.
- **하드 디스크(hard disk)**
    - 사용자가 필요한 데이터와 프로그램을 저장한다.
    - 비휘발성 기억장치다.

<br>

## 캐시(Cache)

캐시 메모리는 CPU와 메인 메모리 간에 데이터 접근 시 속도 차이를 줄이기 위해 사용한다. CPU에서 메인 메모리에 있는 데이터를 가져올 때 자주 사용하는 데이터는 캐시 메모리에 따로 저장하고, 이후에 해당 데이터가 필요하면 캐시 메모리에 접근한다. 이렇게 하면 메인 메모리에 접근하는 것보다 속도를 향상시킬 수 있다. 

캐시 메모리에 어떤 데이터를 저장할지는 지역성을 바탕으로 결정한다. 지역성(locality)은 CPU가 자주 참조하는 데이터가 고르게 분포되지 않고 특정 부분에 몰려 있는 것을 나타낸다. 캐시 적중률을 높이려면 지역성을 바탕으로 데이터를 저장해야 한다.

- **시간 지역성(time locality) :** 최근 참조한 내용을 다시 참조할 가능성이 높다.
- **공간 지역성(space locality) :** 실제 참조한 주소 근처의 내용을 참조할 가능성이 높다.

<br>

## 커널(kernel)

커널은 운영체제 중 항상 메모리에 올라가 있는 운영체제의 핵심 부분으로, 하드웨어와 응용 프로그램 사이에서 인터페이스를 제공하는 역할을 하며 컴퓨터 자원들을 관리하는 역할을 한다. 즉, 커널은 인터페이스로써 응용 프로그램 수행에 필요한 여러가지 서비스를 제공하고, 컴퓨터 하드웨어와 프로세스의 보안, 자원 관리, 하드웨어 추상화 같은 중요한 역할을 수행한다. 특히 자원 관리를 위해 CPU 스케줄링, 메모리 관리, 입출력 관리, 파일 시스템 관리 등을 담당한다. 

*추상화 - 물리적으로 하나뿐인 하드웨어를 여러 사용자들이 번갈아 사용할 수 있도록 마치 여러 개처럼 보이게 하는 기술.*

<br>

## 시스템 콜(system call)

시스템 콜은 사용자 모드에서 커널 모드에 접근해 필요한 기능을 수행할 수 있게 하는 시스템 함수다. 커널은 시스템 콜로 받은 요청을 처리한 후 다시 시스템 콜로 결과 값을 반환한다. 

운영체제는 커널에서 관리하는 중요 자원에 사용자가 쉽게 접근하지 못하도록 커널 모드(kernel mode)와 사용자 모드(user mode)로 모드를 나눈다. 커널 모드에서는 하드웨어에 직접 접근해 메모리, CPU와 같은 자원을 사용할 수 있지만, 사용자 모드에서는 커널 모드의 자원에 접근할 수 없게 제한을 둔다. 

사용자 모드에서 실행된 프로세스가 자원에 접근하려면 시스템 콜을 호출해 커널에 요청해야 한다. 

시스템 콜을 사용해 프로세스 제어, 파일 조작, 장치 관리, 데이터의 유지 보수, 통신, 보호를 할 수 있다. 시스템 콜의 대표적인 예로는 프로세스를 생성하는 fork(), 부모 프로세스가 자식 프로세스의 수행을 기다리는 wait() 등이 있다. 

<br>
<br>

## 프로세스(Process)

프로세스는 컴퓨터에서 실행 중인 하나의 프로그램을 의미한다. OS는 프로그램을 실행하면서 디스크에 저장된 데이터를 메모리로 로드한다. 메모리에 로드한 프로그램을 프로세스라고 한다. 

프로세스는 OS로부터 독립된 메모리 영역(코드, 데이터, 스택, 힙)을 할당받으며, 프로세스당 최소 1개의 스레드를 갖고 있고, 각 프로세스는 별도의 주소 공간에서 실행되며 다른 프로세스의 메모리에 접근할 수 없다. 

<br>

### 프로세스 메모리 영역 구조

- **스택(stack)**
    - 지역 변수, 함수의 매개변수(parameter), 반환되는 주소 값 등이 저장되는 영역
    - 높은 주소 값에서 낮은 주소 값으로 메모리가 할당되며, 영역 크기는 컴파일 때 결정됨
- **힙(heap)**
    - 사용자에 의해 동적 메모리 할당이 일어나는 영역
    - 낮은 주소 값에서 높은 주소 값으로 메모리가 할당되며, 영역 크기는 런타임 때 결정됨.
- **데이터(data)**
    - 전역 변수, 정적 변수, 배열, 구조체 등이 저장되는 영역
    - 데이터 영역은 세부적으로 BSS 영역과 데이터 영역으로 다시 나눌 수 있다.
    - BSS(Block Stated Symbol) : 초기화하지 않은 변수 저장
    - 데이터 : 초기화한 변수 저장
- **코드(code)**
    - 실행할 코드가 기계어로 컴파일되어 저장되는 영역으로, 텍스트(text) 영역이라고도 한다.

<br>

## 스레드(Thread)

프로세스는 한 개 이상의 스레드를 갖는데, 스레드는 프로세스에서 실제로 작업을 수행하는 주체를 의미한다. 스레드는 프로세스 안에 존재하므로 프로세스의 메모리 공간을 이용하고, 프로세스와 달리 스택 영역만 독립적으로 할당 받고, 코드, 데이터, 힙 영역은 다른 스레드와 공유한다. 

<br>

## PCB(Process Control Block)

OS는 프로세스를 제어하기 위해 프로세스 정보를 저장하는데, 이를 PCB라고 한다. PCB는 프로세스의 현재 상태, 프로세스를 나타내는 고유의 PID(Process ID), 부모 프로세스의 PID, 자식 프로세스의 PID, 다음 실행할 명령어의 주소인 PC(Program Counter), 스택 영역에서 데이터가 채워진 가장 높은 주소 값을 가리키는 스택 포인터, 프로세스 우선순위, 메모리 제한 등을 저장한다. 

<br>

## 프로세스 상태

모든 프로세스는 CPU에 의해 생성되고 소멸하는 과정을 거친다.

- **생성(new)**
    - 프로세스가 PCB를 가지고 있지만 OS로부터 *승인* 받기 전
    - *승인(admit) : CPU를 제외한 다른 자원이 준비되어 해당 프로세스가 준비 상태가 될 수 있도록 OS가 허락하는 것.*
- **준비(ready)**
    - OS로부터 승인받은 후 준비 큐에서 CPU 할당을 기다림
- **실행(running)**
    - 프로세스가 CPU를 할당받아 실행
- **대기(waiting)**
    - 프로세스가 입출력이나 이벤트 발생을 기다려야 해서 CPU 사용을 멈추고 기다림
- **종료(terminated)**
    - 프로세스 실행을 종료.

<br>
<br>

## 동시성과 병렬성

동시성(concurrency)은 하나의 코어(싱글 코어)에서 여러 작업을 번갈아 가면서 처리하는 방식이다. CPU는 한 번에 하나의 작업만 처리할 수 있어서 여러 작업을 조금씩 돌아가면서 처리한다.

병렬성(parallelism은 CPU가 여러 개(멀티 코어) 있어서 각 CPU에서 각 작업을 동시에 처리하는 방식이다. 즉, 물리적인 시간 관점에서 동시에 여러 작업이 처리된다.   

<br>

## 멀티 프로세스

멀티 프로세스는 응용 프로그램 하나를 여러 프로세스로 구성하는 것을 의미한다. 멀티 프로세스 환경에서는 한 프로세스가 죽어도 다른 프로세스에 영향을 주지 않는다. 그래서 응용 프로그램을 프로세스 하나로 구성하는 것보다 여러 개로 구성하는 것이 안정적이다. 하지만 시간과 메모리 공간을 많이 사용한다는 단점이 있다. CPU는 하나의 작업만 처리할 수 있으므로, 여러 프로세스를 처리하려면 CPU에서 처리 중인 프로세스를 교체하는 컨텍스트 스위칭 작업이 이루어져야 한다. 이때 CPU에서 기존에 처리하던 프로세스가 할당받은 메모리 영역을 다른 프로세스에서 사용할 수 있게 교체하면서 시간과 메모리가 필요한데, 이를 오버헤드(overhead)라고 한다. 

또한, 프로세스는 독립적인 메모리를 할당받으며 프로세스 간 메모리에 접근이 불가하므로 프로세스간에 공유할 자원이 있다면 IPC를 통해 자원을 공유해야 한다. 그래서 공유할 메모리를 직접 참조하는 것보다 비효율적이다.

<br>

### IPC(Inter Process Communication)

IPC는 프로세스 간에 자원을 공유하는 방식이다. 대표적인 방법으로는 공유 메모리, 소켓, 세마포어, 파이프, 메시지 큐 등이 있다.

<br>

## 멀티 스레드

멀티 스레드는 스레드를 여러 개 생성해 스레드들이 각자 다른 작업을 처리하는 것을 의미한다. 멀티 스레드는 스레드 간에 스택 영역을 제외한 힙, 데이터, 코드 영역을 공유한다. 그래서 컨텍스트 스위칭할 때 오버헤드가 적게 발생하고 IPC를 사용하지 않아도 되어 멀티 프로세스의 단점을 보완할 수 있다. 따라서 독립적인 메모리 공간을 갖는 프로세스를 여러 개 생성하는 것보다 스레드를 여러 개 생성하는 것이 자원을 효율적으로 사용할 수 있다. 하지만 스택 영역을 다른 스레드와 함께 공유하므로 공유 자원에 대한 동기화가 필수다. 또한, 스레드에 문제가 발생하면 프로세스 내 다른 스레드에 영향을 미칠 수 있다. 

<br>

## 인터럽트

인터럽트는 우리말로 ‘방해하다, 중단시키다’라는 뜻으로, 프로세스를 처리하다가 입출력 관련 이벤트가 발생하거나 예외 상황이 발생할 때 이에 대응할 수 있게 CPU에 처리를 요청하는 것을 의미한다. 

<br>

## 컨텍스트 스위칭(Context Switching)

멀티 프로세스 환경에서 CPU가 처리 중인 프로세스의 정보를 바꾸는 것을 의미한다. 

CPU는 하나의 작업만 처리할 수 있으므로 멀티 프로세스를 처리하려면 CPU 스케줄러에 의해 인터럽트가 발생하면서 컨텍스트 스위칭이 이뤄진다. 여기서 컨텍스트란 CPU가 처리하는 프로세스의 정보를 의미한다. 

CPU에서 처리 중인 프로세스가 중간에 변경되어도 이전에 실행하던 코드를 이어서 실행할 수 있는 이유는 PCB에 프로그램 카운터와 스택 포인터 값이 저장되어 있기 때문이다. 프로그램 카운터는 프로세스가 이어서 처리해야 하는 명령어의 주소 값이고, 스택 포인터는 스택 영역에서 데이터가 채워진 가장 높은 주소 값을 가리킨다. 이어서 실행할 명령어의 주소 값이 무엇인지, 데이터가 스택에 어디까지 채워져 있는지 알고 있으므로 컨텍스트 스위칭이 원활하게 이뤄질 수 있다. 

<br>
<br>

## 경쟁 상태(race condition)

여러 프로세스 또는 스레드에서 하나의 공유 자원에 접근하는 경우가 있는데, 이때 자원에 접근하는 순서에 따라 결과 값이 달라질 수 있다. 이러한 현상을 공유 자원에 동시에 접근해 경쟁하는 상태라고 해서 경쟁 상태라고 한다. 

<br>

## 임계 영역(critical section)

공유 자원에 접근할 수 있고 접근 순서에 따라 결과가 달라지는 코드 영역을 임계 영역이라고 한다. 임계 영역에서 경쟁 상태가 발생하는 것을 방지하려면 여러 프로세스가 공유 자원에 접근해도 데이터의 일관성이 유지되도록 프로세스 동기화를 해야 한다. 

임계 영역에 여러 접근이 동시에 발생하는 것을 방지하려면 다음 3가지 조건을 충족해야 한다.

- **상호배제 기법(mutual exclusive)**
    - 어떤 프로세스가 임계 영역을 실행 중일 때 다른 프로세스가 임계 영역에 접근할 수 없다. 상호배제 기법으로는 뮤텍스와 세마포어가 있다.
- **진행(progress)**
    - 임계 영역을 실행 중인 프로세스가 없을 때 다른 프로세스가 임계 영역을 실행한다.
- **한정된 대기(bounded waiting)**
    - 임계 영역에 접근을 요청했을 때 무한한 시간을 기다리지 않는다.

<br>

### 뮤텍스

뮤텍스는 락(lock)을 가진 프로세스만이 공유 자원에 접근할 수 있게 하는 상호배제 기법으로, 락을 가진 한 개의 프로세스만 공유 자원에 접근할 수 있다. 한 개만 접근 가능하므로 반드시 락을 획득한 프로세스가 락을 해제해야 한다. 임계 영역에 접근하지 못한 프로세스는 락을 얻기 위해 기다리는 동안 락이 풀렸는지 반복문을 돌면서 확인한다. 이를 바쁜 대기(busy waiting)의 한 종류인 스핀락이라고 한다. 

즉, 스핀락(spinlock)은 락을 얻기 위해 프로세스가 반복문을 돌면서 기다리는 것을 의미한다. 프로세스가 대기 상태가 되지 않고 반복문을 돌면서 자원의 사용 가능 여부를 확인하므로 프로세스가 빠르게 교체될 수 있다. 

**화장실 예시**

1. 화장실 한 칸과 화장실 문을 열 수 있는 열쇠 한 개가 있다.
2. A가 열쇠를 가지고 화장실에 간다.
3. 화장실에 가려던 B는 열쇠가 없어서 기다린다.
4. A가 화장실에서 나와 열쇠를 반납하면, 기다리던 B가 열쇠를 가지고 화장실에 간다.

*화장실(임계 영역), 열쇠(락), A와 B(공유 자원에 접근하려는 프로세스)*

<br>

### 세마포어

세마포어는 공유 자원에 접근할 수 있는 프로세스의 수를 정해 접근을 제어하는 방법이다. 현재 수행 중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있다. 공유 자원에 접근할 수 있는 프로세스의 수를 제어하기 위한 정수 변수를 사용하며, 임계 영역에 접근할 수 있는 키 n개를 지정하고 이 중 하나를 가진 프로세스만이 임계 영역에 접근하게 하는 방식이다. 이 방식은 공유 자원에 접근한 프로세스가 접근을 해제하면 다른 프로세스가 접근할 수 있도록 신호를 보낸다고 해서 시그널링 매커니즘(signaling mechanism)이라고도 한다. 

**화장실 예시**

1. 화장실 3칸, 화장실을 열 수 있는 열쇠가 3개 있다.
2. A가 화장실 열쇠 하나를 가지고 화장실에 간다. 열쇠는 2개가 남는다.
3. B, C가 열쇠를 하나씩 가지고 화장실에 간다. 남은 열쇠가 없어서 D는 화장실에 가지 못한다.
4. C가 화장실에서 나와 열쇠를 돌려놓으면, D가 화장실에 간다. 

<br>

## 교착 상태(Deadlock)

상호배제 기법 때문에 2개 이상의 프로세스가 각각 자원을 가지고 있으면서 서로의 자원을 요구하며 무한히 기다리는 상태를 의미한다. 교착 상태가 발생하는 4가지 필요 충분 조건이 있다. 교착 상태를 막으려면 4가지 필요 충분 조건 중에서 한 가지를 제거하면 된다.

- **상호배제(mutual exclusion)**
    - 하나의 공유 자원에 하나의 프로세스만 접근할 수 있다.
- **점유와 대기(hold and wait)**
    - 프로세스가 최소 하나의 자원을 점유하고 있는 상태에서 추가로 다른 프로세스에서 사용 중인 자원을 점유하기 위해 대기한다.
- **비선점(non-preemption)**
    - 다른 프로세스에 할당된 자원을 뺏을 수 없다.
- **환형 대기(circular wait)**
    - 프로세스가 자신의 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구한다.

<br>
<br>

## 스케줄링 알고리즘

스케줄링 알고리즘은 CPU 스케줄러(단기 스케줄러)가 준비 큐에 있는 프로세스 중 어떤 프로세스를 실행시킬지 결정하는 데 사용한다. 스케줄링 알고리즘은 스케줄링의 목적을 달성하기 위해 다음과 같은 기준으로 평가한다. 하지만 이를 모두 만족하기는 어려우므로 어떤 기준을 더 중요하게 여길지 판단해야 한다.

- **CPU 사용률** : CPU를 놀리지 않고 사용하는지 판단
- **처리량** : 단위 시간 당 실행한 프로세스 수
- **응답 시간** : 프로세스에 요청이 발생했을 때 응답까지 걸리는 시간
- **반환 시간** : 프로세스가 로드된 이후부터 종료될 때까지 걸리는 시간
- **대기 시간** : 프로세스가 대기 큐에서 대기하는 시간의 총합

<br>

### 비선점 스케줄링

비선점형 스케줄링은 실행 중인 프로세스가 종료될 때까지 다른 프로세스를 실행할 수 없음을 의미한다. 

<br>

### 선점형 스케줄링

선점형 스케줄링은 스케줄러가 실행 중인 프로세스를 중단시키고 다른 프로세스를 실행할 수 있음을 의미한다.

<br>
<br>

## 가상 메모리(Virtual Memory)

가상 메모리는 **메모리 공간의 한계를 극복**하기 위해 나온 방식으로, **프로세스의 일부만 메모리에 로드하고, 나머지는 디스크에 둔 상태로 프로세스를 실행하는 방식**이다. 이 방식은 프로세스 전체가 메모리에 올라오지 않아도 프로세스를 실행하는 데 문제가 없다는 점에서 착안했다. 사용자에게는 프로세스 전체가 메모리에 로드된 것처럼 보이지만, 실제로는 전체가 로드된 것이 아니어서 가상 메모리라고 한다. 

가상 메모리를 사용하면 프로그램이 메모리 크기에 대한 제약을 덜 받을 수 있고, 동시에 많은 프로그램을 실행하므로 CPU 이용률과 처리율을 높일 수 있다. 또한 필요한 영역만 메모리에 로드해 스와핑 횟수를 줄여서 프로그램 실행 속도를 높일 수 있다. 

<br>

### 요구 페이징(Demand Paging)

요구 페이징은 프로세스에서 필요한 페이지만 메모리에 로드하는 방식이다. 페이지를 모두 메모리에 로드하지 않고 초기에 필요한 영역만 로드한 후 다른 영역은 요청이 올 때 메모리에 로드한다. 

프로그램을 실행하다가 물리 메모리에 필요한 페이지가 없을 때 이를 페이지 폴트(page fault)라고 한다. 페이지 폴트가 발생하면 디스크에서 필요한 페이지를 스왑 인한다. 이때 페이지에 해당하는 메모리 영역이 물리 메모리에 있는지는 페이지 테이블로 파악할 수 있다. 페이지 테이블은 페이지에 해당하는 프레임이 존재하면 ‘v(valid)’ 값을, 프레임이 존재하지 않거나 유효하지 않은 주소 값이면 ‘i(invalid)’ 값을 반환한다. 

<br>

**페이지 폴트가 발생했을 때 처리 과정**

1. 필요한 페이지가 물리 메모리에 있는지 없는지를 페이지 테이블에서 확인한다. 페이지 폴트가 발생하면 i를 반환한다.
2. i를 반환하면 OS는 참조하려는 페이지의 주소 값이 유효하지 않은지 아니면 메모리에 로드되지 않은 영역인지를 판단한다.
3. 필요한 페이지가 메모리에 로드되지 않은 영역이라면 디스크에서 해당 영역을 찾는다.
4. 디스크에서 해당 페이지 영역을 스왑 인한다. 이때 물리 메모리에 비어 있는 프레임이 있으면 페이지를 해당 영역에 바로 로드하고, 비어 있는 프레임이 없으면 페이지 교체 알고리즘을 호출해 기존에 로드된 페이지를 디스크로 스왑 아웃한 후 새로운 페이지를 로드한다.
5. 페이지 테이블에서 새로 로드한 페이지의 값을 v로 변경한다.
6. 프로세스를 다시 실행한다.

<br>

- **스왑 아웃(swap out)** : 이벤트 발생을 기다리고 있는 프로세스를 통째로 저장공간(SSD와 같은 영역)으로 옮겨 저장하는 것.
- **스왑 인(swap in)** : 스왑 아웃한 프로세스에서 이벤트 요청이 오면 해당 프로세스를 통째로 다시 메모리에 로드하는 것.
- **스와핑(swapping)** : 스왑 아웃과 스왑 인처럼 프로세스를 통째로 메모리 영역과 저장 공간으로 옮기는 것. 스와핑하면 메모리 공간보다 많은 프로세스를 실행할 수 있다는 장점이 있다.

<br>

### 스레싱(Thrashing)

스레싱은 메모리의 페이지 폴트율이 높은 것을 의미한다. 어떤 프로세스가 실제 실행보다 더 많은 시간을 페이징에 사용하고 있으면 스레싱이 발생했다고 한다. 가상 메모리를 구현해 다중 프로그래밍(multi programming)을 하면 CPU 이용률이 높아진다. 하지만 일정 수 이상으로 다중 프로그래밍을 하면 페이지 폴트가 자주 일어난다. 따라서 디스크 영역에서 필요한 페이지를 스왑 인하고 불필요한 페이지를 스왑 아웃하는 작업도 자주 하게 된다. 이처럼 다중 프로그래밍 정도가 일정 수준 이상 높아지면 페이징이 빈번히 일어나게 되고 실질적으로 CPU 이용률이 떨어지는 스레싱이 발생한다. 

(페이지 폴트가 일어나면 CPU 이용률이 낮아지고, 운영체제는 가용성을 높이기 위해 더 많은 프로세스를 올리는 악순환이 반복되며 스레싱 발생)

스레싱을 예방하려면 워킹 세트(working set)를 설정하는 방법이 있다. 워킹 세트는 지역성을 기반으로 자주 사용하는 페이지를 저장해 두는 것을 의미한다. 워킹 세트를 바탕으로 자주 사용하는 페이지를 물리 메모리의 프레임에 고정하면 페이지 폴트가 빈번하게 발생하는 현상을 방지할 수 있다.

<br>
<br>
