# Database 
이민정 

<br>
<br>

## 목차

<br>
<br>


## **관계형 데이터베이스(RDB, Relational Database)**

데이터가 2차원 테이블에 저장되며 데이터의 구조와 데이터 간 종속성 등을 알 수 있다. 스키마를 바탕으로 데이터베이스의 구조를 정의하는데, 스키마는 개체-관계 다이어그램(ERD, Entity-Relational Diagram) 또는 문자열로 표현할 수 있다. 테이블은 키(key)와 값(value)의 관계를 나타낸다. 데이터의 종속성을 관계(relationship)로 표현하는 것이 관계형 데이터베이스의 특징이다. 

<br>

### 관계형 데이터베이스 용어

- **열(column)**
    - 이름과 타입을 가진 데이터의 속성으로, 필드(field) 또는 속성(attribute)라고 부른다.
- **행(row)**
    - 관계된 데이터의 묶음을 의미.
    - 튜플(tuple) 또는 레코드(record)라고 부른다.
- **값(value)**
    - 테이블은 각각의 행과 열에 대응하는 값을 가지고 있다.
    - 값은 열의 타입에 맞는 값이어야 한다.
- **키(key)**
    - 데이터베이스에서 튜플을 구분하기 위한 속성 또는 속성의 집합을 의미한다.
    - 키는 유일성과 최소성이라는 두 가지 특성을 가질 수 있다.
    - 슈퍼 키, 후보 키, 기본 키, 대체 키, 외래 키
- **관계(relationship)**
    - 테이블 간의 관계
    - 일대일(one-to-one) 관계
    - 일대다(one-to-many) 관계
    - 다대다(many-to-many) 관계
    - 관계형 데이터베이스에서는 이러한 관계를 나타내기 위해 외래 키(foreign key)라는 것을 사용.
- **스키마(schema)**
    - 개체-관계 다이어크램이나 문자열로 표현할 수 있다.

<br>

### 테이블

데이터베이스에서 데이터를 저장하는 기본 단위로, 행과 열로 이루어진 2차원 형태이다. 행은 데이터 묶음을 뜻하며, 튜플 또는 레코드라고도 한다. 열은 이름과 타입을 가진 데이터의 속성으로, 필드라고도 한다. 

<br>

### 뷰

하나 이상의 테이블에서 SQL 쿼리의 결과 셋을 기반으로 만들어진 일종의 가상 테이블이다. 실제로 데이터를 저장하지 않고 기존 테이블의 데이터를 기반으로 쿼리를 실행하여 필요한 정보를 반환한다. 뷰를 통해 데이터의 일부분에 집중하거나 복잡한 쿼리를 간소화할 수 있다. 

뷰를 사용하면 필요한 데이터만을 노출하고, 민감한 정보나 기밀성이 필요한 데이터를 숨길 수 있으므로 보안, 효율성 및 유지보수 측면에서 유용하게 사용할 수 있다. 또한 동일한 뷰를 여러 사용자 또는 응용 프로그램에서 재사용할 수 있으므로, 데이터베이스 객체의 재사용성을 높이고 일관성을 유지할 수 있다. 

하지만 실제 데이터를 기반으로 동적으로 생성되기 때문에 쿼리 실행 시 추가적인 계산이 필요하며 이로 인해 성능이 저하될 수 있다. 

<br>
<br>

## 인덱스(Index)

인덱스는 데이터베이스에서 튜플의 **검색 성능을 높이기 위해** 속성 값과 튜플이 저장된 주소를 저장하는 것을 말한다. 키-값 형태로 ‘속성 값-튜플 주소’를 인덱스 테이블에 저장한다. 인덱스 테이블은 속성 값을 기준으로 정렬 상태를 유지한다. 

<br>

### 인덱스 장점

- 인덱스 테이블에 데이터가 정렬되어 있어서 검색 속도가 빠르다.
- 조인 성능 향상
- WHERE절 최적화

### 인덱스 단점

- 인덱스 테이블을 저장하기 위한 추가 공간이 필요하다.
- 정렬된 상태를 유지하기 위해 데이터를 추가, 수정, 삭제하는 경우에는 속도가 느리다.

<br>

### 인덱스 자료구조

인덱스를 구현하는 대표적인 방법으로는 해시 테이블과 B-Tree, B+Tree가 있다. 

<br>

#### Hash Table

해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용하다. 해시 테이블은 속성 값으로 해시 값을 계산해 인덱싱하는 방법이다. (키 값을 이용해 고유한 인덱스를 생성, 그 인덱스에서 저장된 값을 꺼내오는 구조) 

해시 함수의 특성상 속성 값을 그대로 검색해야 해서 검색하려는 값을 온전히 입력할 때만 사용할 수 있기 때문에 등호 연산만 가능하다. 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하므로 부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않다. 

#### B-Tree, B+Tree

인덱스 테이블을 구현할 때 트리 구조의 B+Tree 인덱스 또는 B-Tree 인덱스 방식을 많이 사용한다. 여기서 B는 Balanced를 의미한다. B+Tree는 단말 노드에만 데이터를 저장하고 단말 노드 간에는 연결 리스트로 연결되는 방식이고, B-Tree는 모든 노드에 데이터가 저장되는 방식이다. 

B+Tree나 B-Tree 인덱스를 사용하면 데이터의 삽입, 갱신, 삭제 등에 드는 작업 비용을 줄일 수 있다. 또한, 해시 테이블 인덱스와 달리 속성을 범위로 검색할 수 있어서 비교 연산이 가능하다. 

<br>
<br>

## NoSQL

NoSQL(Not Only SQL)은 비관계형 데이터베이스로, 보다 유연한 형태의 데이터베이스를 의미한다. 관계형 데이터베이스와 달리 다양한 형태(Document, Graph, Key-Value, Wide-Column)의 데이터를 저장할 수 있다. NoSQL은 일반적으로 스키마가 유연하며, 수평적 확장이 가능하도록 설계되어 대용량 데이터 처리와 분산 환경에서 우수한 성능을 제공할 수 있다. 때문에 주로 빅데이터, 분산 시스템 환경에서 대용량의 데이터를 처리하는데 적합하다.

### NoSQL 특징

- 관계형 데이터베이스와 달리 데이터 간의 관계(Relation)을 정의하지 않는다.
- 관계형 데이터베이스에 비해 대용량의 데이터를 저장할 수 있다.
- 분산형 구조로 설계되어 있다.
- 고정되어 있지 않은 테이블 스키마를 갖는다.

### NoSQL 장, 단점

**장점**

- 관계형 데이터베이스에 비해 저렴한 비용으로 분산처리와 병렬 처리가 가능하다.
- 비정형 데이터 구조 설계로 설계 비용 감소
- 빅데이터 처리에 효과적
- 가변적인 구조로 데이터 저장 가능
- 데이터 모델의 유연한 변화 가능

**단점**

- 데이터 일관성이 항상 보장되지 않는다.
- 데이터 업데이트 중 장애가 발생하면 데이터 손실 발생 가능

<br>
<br>

## 트랜잭션(Transaction)

트랜잭션은 데이터베이스의 상태를 바꾸기 위해 수행하는 작업의 단위 또는 일련의 연산을 의미한다. 데이터베이스 시스템에서 여러 연산이 동시에 수행될 때 데이터의 일관성과 무결성을 유지하기 위한 개념이다. 트랜잭션은 ACID 속성을 따른다. 

<br>

### 트랜잭션 4가지 특성(ACID)

- **원자성(Atomicity)**
    - 트랜잭션이 데이터베이스에 완전히 반영되거나 아예 실행되지 않아야 한다.
- **일관성(Consistency)**
    - 트랜잭션의 작업 처리 결과는 항상 일관성이 있어야 한다.
- **격리성(Isolation)**
    - 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들 수 없다.
- **영속성(Durability)**
    - 성공적으로 완료한 트랜잭션의 결과가 데이터베이스에 영구적으로 반영된다.

<br>

### 트랜잭션 격리 수준(Transaction Isolation Level)

트랜잭션의 격리 수준이란 여러 트랜잭션이 서로 영향을 미치지 않고 실행될 수 있는 단계를 의미한다. 트랜잭션의 격리 수준은 격리 수준이 높은 순서대로 Serializable, Repeatable Read, Read Commited, Read Uncommited의 4단계가 존재한다. 

- **Serializable**
    - 가장 엄격한 격리 수준으로, 이름 그대로 트랜잭션을 순차적으로 진행시킨다.
    - 트랜잭션이 읽은 데이터를 다른 트랜잭션이 갱신, 삭제, 삽입할 수 없다.
    - 여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없으므로, 어떠한 데이터 부정합 문제도 발생하지 않는다.
    - 트랜잭션이 순차적으로 처리되어야 하므로 동시 처리 성능이 매우 떨어지고, 교착 상태가 일어날 확률도 많다.
- **Repeatable Read**
    - 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정(갱신, 삭제)할 수 없도록 막아주지만 새로운 행을 추가하는 것은 막지 않는다.
    - Phantom Read 문제가 발생할 수 있다.
- **Read Commited**
    - 커밋된 데이터만 다른 트랜잭션이 조회할 수 있다.
    - 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있다.
    - Non-Repeatable Read, Phantom Read 문제가 발생할 수 있다.
    - 가장 많이 사용되는 격리 수준으로 대부분의 RDBMS의 기본 설정이다.
- **Read Uncommited**
    - 가장 낮은 격리 수준으로, 트랜잭션의 커밋 여부와 상관없이 다른 트랜잭션이 데이터를 조회할 수 있다.
    - 한 번에 여러 트랜잭션을 처리할 수 있는 동시성은 높지만, 데이터의 일관성을 유지하기 어렵다.
    - Dirty Read, Non-Repeatable Read, Phantom Read 문제가 발생할 수 있다.

<br>

### 격리 수준에 따라 발생하는 현상

- **Dirty Read**
    - 아직 커밋 되지 않은 다른 트랜잭션의 데이터를 읽는 것을 의미.
- **Non-Repeatable Read**
    - 다른 트랜잭션이 커밋한 데이터를 읽을 수 있는 것으로, 같은 트랜잭션 내에서 같은 데이터를 여러 번 조회 했을 때 읽어온 데이터가 다른 경우를 의미.
- **Phantom Read**
    - 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 없던 행이 추가되어 새로운 데이터를 읽게 되거나 존재하던 데이터가 사라져서 해당 조회 결과가 다른 경우를 의미.

<br>

### 데이터베이스 락(Database Lock)

락은 트랜잭션이 처리되는 순서를 보장해 무결성을 유지하는 방법이다. 운영체제에서 데이터 동기화를 위해 임계 영역에 대한 접근을 제한하는 상호배제 기법과 유사하다. 데이터의 무결성을 유지하기 위한 락이 여러 종류가 있는데, 대표적으로는 공유 락과 베타 락이 있다.

- **공유 락(Shared Lock)**
    - 데이터를 읽는 락으로, 읽기 락(read lock)이라고도 한다. 데이터를 읽는 연산이므로 데이터의 일관성에 영향을 주지 않아 데이터에 여러 공유 락이 동시에 접근할 수 있다.
- **베타 락(Exclusive Lock)**
    - 데이터를 수정하는 락으로, 쓰기 락(write lock)이라고도 한다. 데이터의 일관성을 유지하기 위해 데이터에 하나의 베타 락이 접근 중일 때 다른 베타 락이 접근할 수 없다.

<br>

### 데이터베이스 교착 상태(Database Deadlock)

데이터베이스의 트랜잭션도 프로세스처럼 교착 상태에 빠질 수 있다. 이는 한 트랜잭션이 자신이 처리 중인 데이터에 대해 락을 가진 상태에서 다른 트랜잭션이 처리 중인 데이터에 대해 락을 요청해 무한 대기 상태에 빠진 현상을 의미한다. 즉, 특정 데이터의 락을 가지고 있는 트랜잭션이 다른 데이터의 락을 추가로 요청하며 발생한다. 

<br>

### 교착 상태 해결 방법

- **예방 기법**
    - 각 트랜잭션이 실행되기 전에 필요한 데이터를 모두 잠금하는 것. 하지만 데이터가 많이 필요할 경우 모든 데이터를 잠금해야 하기 때문에 트랜잭션의 병행성을 보장하지 못한다.
    - 몇몇 트랜잭션들은 계속해서 처리를 못하게 되는 기아 상태가 발생할 수 있다.
- **회피 기법**
    - 예방 기법의 단점 때문에 실제로 교착 상태를 해결하기 위한 방법이다.
    - 자원을 할당할 때 시간 스탬프(Time Stamp)를 사용하여 교착상태가 일어나지 않도록 회피하는 방법으로, Wait-Die 방식과 Wound-Wait 방식이 있다.
    - Wait-Die
        - 비선점 기법이다.
        - 다른 트랜잭션이 데이터를 점유하고 있을 때 기다리거나(Wait) 포기(Die)하는 방식으로 선행 트랜잭션이 접근하면 대기(wait), 후행 트랜잭션이 접근하면 포기(die)한다.
        - 즉, 오래된 트랜잭션에게 대기의 기회를 제공하고, 최신 트랜잭션은 자주 복귀함으로써 오버헤드의 가능성이 있다.
    - Wound-Wait
        - 선점 기법이다.
        - 다른 트랜잭션이 데이터를 점유하고 있을 때 빼앗거나(Wound) 기다리는(Wait) 방식으로, 선행 트랜잭션이 접근하면 선점(wound), 후행 트랜잭션이 접근하면 대기(wait) 한다. 즉, 오래된 트랜잭션에게 선점의 기회를 제공하고 최신 트랜잭션은 대기함에 따라 복귀를 최소화한다.

<br>
<br>

## ORM

ORM(Object-Relational Mapping)은 객체와 관계형 데이터베이스를 매핑하는 도구를 의미한다. 

데이터베이스를 프로그래밍 언어의 객체 관점으로 바라볼 수 있어서 객체 지향 프로그래밍 언어를 이용해 프로그램을 개발할 때 편리하다. SQL 문을 사용하지 않고 객체 지향적 코드를 작성할 수 있어서 코드의 가독성을 높이고 개발자 편의성을 증대할 수 있다. 대표적인 ORM 프레임워크로는 자바의 하이버네이트(Hibernate), 파이썬의 장고(Django) 등이 있다. 

<br>

### JPA, MyBatis 차이점

마이바티스(MyBatis)와 JPA(Java Persistence API)는 둘 다 데이터베이스 엑세스를 위한 자바 기반의 프레임워크이지만, 동작 방식과 사용 방법에 차이가 있다. 

마이바티스는 SQL 기반의 쿼리 매핑을 중심으로 하는 데이터베이스 엑세스 프레임워크로, SQL 매핑을 주로 XML 파일을 통해 정의한다. SQL 문장이 명시적으로 존재하며, 개발자가 쿼리에 대한 전체적인 통제를 가진다. 

반면에 JPA는 객체와 관계형 데이터베이스 간의 매핑을 중시하는 ORM 프레임워크로, 어노테이션 기반으로 객체와 테이블 간의 매핑을 정의한다. 대부분 쿼리는 JPQL을 사용하며, 네이티브 SQL도 사용 가능하다.

<br>
<br>
<br>
