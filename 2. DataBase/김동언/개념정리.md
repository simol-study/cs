# DataBase - 김동언

## 중요 Key 포인트
* 무결성
* 일관성

<br>
<br>

## 목차
[Table](#Table)  
[View](#View)  
[RDB](#RDB)  
[NoSQL](#NoSQL)  
[RDB와 NoSQL 차이점](#RDB와-NoSQL-차이점)  

<br>
<br>

## Table
테이블이란 데이터를 저장하는 기본 단위입니다. 행과 열로 이루어진 2차원 배열이며 행은 레코드 열은 속성을 의미합니다.
기본키를 통해 각 레코드를 식별하며 외래키를 통해 데이터 간 복잡한 관계를 효과적으로 관리할 수 있습니다.
테이블을 사용하면 정해진 스키마에 따라 데이터를 저장하므로 무결성과 일관성을 유지할 수 있습니다.

정리
* 데이터를 저장하는 기본 단위
* 행과 열로 이루어짐 (행 : 레코드, 열 : 속성)
* 기본키를 통해 각 레코드를 식별
* 외래키를 통해 데이터 간 복잡한 관계를 효과적으로 관리
* 데이터 무결성과 일관성을 유지 

<br>
<br>

## View
View란 하나 이상의 테이블이나 뷰로 만들어지는 '가상 테이블'입니다. 
View는 하나의 SELECT 문과 같다고 생각할 수 있습니다.  
JOIN, GROUP과 같은 복잡한 쿼리문의 결과를 View로 정의할 수 있습니다. 
사용자들은 복잡한 쿼리문을 매번 작성하지 않아도 필요한 데이터에 쉽게 접근할 수 있습니다. 
View는 여러 사용자나 응용 프로그램에서 사용할 수 있어 효율성이 좋습니다.
원하는 정보만 선택해 보여주고 특정한 정보를 숨길 수 있어 보안에 좋습니다. 

<br>

View 특징 
* 하나 이상의 테이블이나 뷰로 만들어지는 가상 테이블
* 한 개의 테이블에 여러 뷰를 생성할 수 있음
* 한 개의 뷰에 여러 테이블의 데이터를 검색할 수 있음 

<br>

View 장점
* 보안 : 원하는 정보만 보여주고 나머지 정보는 숨길 수 있어 보안에 좋습니다. 
* 개발 편의성 : 복잡한 쿼리를 뷰로 정의하면 매번 복잡한 쿼리를 작성하지 않아도 원하는 데이터를 얻을 수 있습니다.
* 재사용성 : 한 번 정의된 뷰는 여러 사용자나 응용 프로그램에서 재사용할 수 있습니다. 

<br>

View 단점
* 유연성 제한 : 한 번 정의된 뷰는 변경할 수 없습니다.
* 성능 저하 : 복잡한 뷰는 성능 저하를 일으킬 수 있습니다. 많은 양의 데이터와 여러 테이블의 조인이 포함된 뷰는 처리 시간이 길어질 수 있습니다. 

<br> 
<br>

## RDB

Relation DataBase   
RDB란 관계형 데이터베이스 입니다.   
RDB를 사용하면 데이터 무결성과 일관성을 유지할 수 있습니다. 
RDB는 정해진 스키마에 따라 데이터를 테이블 형태로 저장합니다.
기본키를 통해 레코드를 식별하며 외래키를 통해 테이블 간의 관계를 정의합니다. 
트랜잭션을 지원하여 데이터의 안정성과 신뢰성을 보장합니다. 

RDB의 특징은 테이블끼리 관계를 가진다는 겁니다. 
관계를 이용하면 복잡한 쿼리문을 사용할 수 있어 여러 개의 테이블을 조합하여 정보를 다룰 수 있습니다. 

RDB는 데이터의 정확성, 무결성이 중요하고 복잡한 쿼리가 필요할 때 사용됩니다. 

<br>

RDB 특징
* 관계형 DB 
* 무결성, 일관성 유지
  * 기본키, 외래키 
  * 트랜잭션
* 복잡한 쿼리문 지원 
* 수직적 확장(성능을 높이는 방법)
* 예시 : MySQL, MariaDB, PostgreSQL...

<br>

RDB 장점 
* 일관성 : 정해진 스키마에 따라 데이터를 저장합니다. 이러한 특성으로 트랜잭션 ACID를 만족하여 일관성을 보장합니다.
* 복잡한 쿼리문 : 테이블끼리 관계를 맺고 있어 여러 테이블에서 정보를 종합해서 가져올 수 있습니다. 

<br>

RDB 단점
* 유연성 부족 : RDB는 정해진 스키마를 요구합니다. 데이터 구조가 자주 바뀌거나 비정형 데이터를 다룰 때 유연성이 떨어질 수 있습니다.
* 확장성 부족 : 대규모 분산 시스템에서의 확장성에 제한이 있습니다. 더 많은 서버를 사용하는 수평 확장에서 일관성을 유지하며 동기화하기 어렵습니다. 

<br>

대규모 비정형 데이터 환경에서 RDB는 데이터를 저장하기 위해서는 RDB에 맞게 가공하는 작업이 필요합니다. 이 작업은 대규모 데이터일 때 성능 저하를 일으킬 수 있습니다.
여러 서버를 사용하는 분산 환경에서 RDB는 엄격한 구조로 인해 동기화가 어려워 일관성을 유지하기 힘들어 적합하지 않습니다.

이러한 단점을 극복하기 위해 NoSQL이 등장했습니다. 

<br>
<br>

## NoSQL
Not only SQL   
NoSQL이란 비관계형 데이터베이스 입니다.
NoSQL은 주로 Key Value 형식으로 데이터를 저장합니다.  
그 외에도 다양한 형태의 데이터 타입을 지원합니다.  
NoSQL은 분산형 구조를 이루고 있어 여러 개의 서버에서 데이터를 처리할 수 있습니다.
데이터 처리가 빠르며 하나의 서버가 다운되어도 나머지 서버가 일을 할 수 있어 고가용성입니다. 
이러한 특성으로 NoSQL 대규모 비정형 데이터 처리에 적합합니다. 

NoSQL 유연한 스키마, 빠른 처리, 대규모 데이터 분산 처리에 적합합니다. 

<br>

NoSQL 특징 
* 관계를 맺지 않는 비관계형 데이터베이스
* 대규모 비정형 데이터 처리에 용이 
  * 다양한 데이터 타입 지원
  * 분산형 구조 
* 데이터 읽기, 쓰기 작업 빠름
* 수평 확장 용이(서버 개수 증가)
* 예시) Redis, MongoDB, Cassandra...

<br>

NoSQL 장점
* 유연성 : Key Value, 문서, 그래프 등 다양한 데이터 타입을 지원합니다. 이로 인해 가공 작업 없이 통째로 데이터를 처리할 수 있어 성능이 빠릅니다.
* 분산 구조 : 여러 서버를 통해 데이터를 처리할 수 있어 대규모 데이터에 대해 빠른 성능과 고가용성을 제공합니다.

<br> 

NoSQL 단점
* 일관성 부족 : 엄격한 스키마와 트랜잭션을 지원하지 않아 일관성이 약합니다. 네트워크 에러가 발생해도 나머지 서버들은 계속 동작하므로 일관성이 깨질 수 있습니다.
* 데이터 중복 : 데이터 중복으로 인해 수정이 번거롭습니다. 데이터를 UPDATE 하는 경우 모든 컬렉션에서 수행해야 합니다. 
* 쿼리 미지원 : 관계를 맺지 않으므로 여러 릴레이션에서 종합해서 정보를 가져올 수 없습니다. 

<br>

NoSQL은 RDB가 처리하기 힘든 대규모 비정형 데이터를 처리하기 위해 등장했습니다.  
분산 구조와 다양한 데이터 타입으로 대량의 데이터를 처리하는데 용이하지만 그에 대한 대가로 데이터 중복으로 인해 일관성이 깨졌습니다. 
성능과 일관성은 Trade Off 관계임을 알 수 있습니다. 
NoSQL은 대규모 데이터와 데이터 타입이 빠르게 변화하는 환경에서 주로 사용합니다. 

<br>
<br>

## RDB와 NoSQL 차이점
RDB는 일관성과 무결성에 중점을 두었고 NoSQL은 대규모 데이터 처리에 중점을 두었습니다.   

RDB는 관계를 맺지만 NoSQL은 관계를 맺지 않습니다. 이로 인해 RDB는 복잡한 쿼리문을 통해 여러 테이블에 걸쳐 데이터를 종합해 가져올 수 있지만 NoSQL은 그러지 못합니다.  
RDB는 트랜잭션 ACID를 적용해 일관성을 유지하지만 NoSQL은 그러지 못해 일관성이 부족할 수 있습니다.  

NoSQL은 다양한 데이터 타입을 지원하여 유연하지만 RDB는 정해진 스키마가 있어 유연하지 않습니다.  
성능을 높일 때 NoSQL은 서버를 늘리는 Scale Out, RDB는 하드웨어 성능을 높이는 Scale Up에 적합합니다.   
서버를 늘리는 비용이 성능을 높이는 비용보다 저렴하므로 성능을 높일 때 NoSQL이 유리합니다.  

NoSQL은 대규모 비정형 데이터 처리에 유리하고 RDB는 무결성, 일관성이 중요한 데이터 처리에 유리합니다. 


|       | RDB                  | NoSQL             |
|-------|----------------------|-------------------|
| 관계    | 테이블끼리 관계를 맺음         | 관계를 맺지 않음         |
| 쿼리문   | 복잡한 쿼리문 지원           | 단순한 CRUD          |
| 유연성   | 스키마에 따라 정해져 있음       | 다양한 데이터 타입 지원     |
| 성능 확장 | Scale Up(하드웨어 성능 높임) | Scale Out(서버를 늘림) |
| 중점    | 무결성, 일관성 중요          | 대규모 비정형 데이터 처리 중요 |

<br>
<br>

## Index 
인덱스란 테이블의 검색 속도를 향상시키는 자료 구조입니다. 
책의 목차 같은 개념으로 인덱스를 사용하면 모든 레코드를 탐색하는 대신 인덱스만 탐색하므로 검색 속도가 빨라집니다.
반면 인덱스를 사용하면 데이터의 추가, 삭제 성능은 하락됩니다. 데이터가 변경될 때마다 인덱스도 업데이트하기 때문입니다.
그러므로 인덱스는 읽기가 많고 변경이 적은 속성에 사용하는 것이 효과적입니다.
또한, WHERE, JOIN이 자주 사용되는 속성에 사용하는 것도 효과적입니다. 
인덱스를 사용하기 위해서는 추가적인 공간이 필요합니다. (대략 10%)

<br>

정리
* 검색 속도 향상
* 데이터의 추가, 삭제 성능 하락 
* 10% 추가 공간 필요 
* 읽기 작업이 많고 변경이 적은 속성에 사용하면 효과적임
* WHERE, JOIN이 자주 사용되는 속성에 적용하면 효과적짐

<br>

인덱스에서 사용하는 대표적인 자료구조로는 B+Tree가 있습니다.
B+Tree는 B-Tree를 보안해서 등장했습니다.

<br>
<br>

## Index 사용하는 자료구조

인덱스에서 사용하는 자료구조는 B-Tree, B+Tree, HashTable 등이 있습니다. 

B-Tree, B+Tree는 RDB의 인덱스로 사용됩니다.  
트리 형태로 균일한 높이를 유지하여 일정한 검색 속도를 보장합니다. 
이로 인해 비교 연산이 가능하며 범위 검색에 효율적 입니다.
하지만 데이터의 추가, 삭제 작업시 트리의 높이를 유지하기 위한 추가 작업이 필요합니다. 

Hash Table은 NoSQL, 캐시 시스템, 해시 맵 구현 등에 사용됩니다.
키-값 쌍으로 데이터를 저장하고 빠른 검색 속도를 제공합니다.
키를 사용하여 데이터 접근이 편리합니다. 이로 인해 등호 검색(=)에 효율적입니다.
즉, 입력하려는 값을 온전히 입력해야 사용할 수 있습니다. 
이러한 특성으로 범위 검색에는 비효율적이며 해시 충돌을 관리해야 합니다.  

<br>

B-Tree, B+Tree 특징
* RDB의 인덱스로 사용 
* 비교 연산 가능, 범위 검색에 효율적
* 트리의 높이가 균일하여 일정한 검색 속도를 보장 
* 데이터 추가, 삭제 시 트리의 균형을 유지하기 위해 추가적인 작업이 필요

<br>

Hash Table 특징 
* 메로리 DB 인덱스, Cache 구현 사용 
* 등호 연산 효율적 
* 빠른 검색 속도 보장 
* 범위 검색에 비효율이며 해시 충돌을 관리 필요 

<br>
<br> 

## B-Tree와 B+Tree
B : Balance  
균형 이진 트리 

B-Tree와 B+Tree는 트리 형태의 자료구조 입니다.   
B+Tree는 B-Tree는 기반으로 만들어졌습니다.  

데이터 저장  
B-Tree는 데이터를 모든 노드에 저장합니다.
B+Tree는 리프 노드에 데이터를 저장합니다. 리프 노드는 링크드리스트로 연결되어 있습니다.  
B+Tree의 리프 노드외에는 포인터만 저장되어 있습니다. 이는 메모리를 효율적으로 사용하여 B-Tree 보다 많은 포인터를 담을 수 있어 트리의 높이가 낮아집니다. (B-Tree는 포인터 + 데이터를 담고 있으므로 포인터만 담고 있는 B+Tree가 더 많은 포인터를 담을 수 있다.)
이로 인해 B+Tree는 어떤 데이터를 검색하든 일정한 속도와 빠른 속도를 제공합니다.


데이터 접근  
B-Tree는 루트 노드에 가까울수록 빠르게 검색할 수 있습니다. 단일 검색에 유리합니다.  
B+Tree는 데이터가 모두 리프 노드에 있어 일정한 검색 속도를 보장합니다. 리프 노드는 연결되어 있어 범위 검색에 유리합니다.  

풀스캔  
B-Tree는 모든 노드를 탐색합니다.  
B+Tree는 리프 노드만을 탐색합니다. B+Tree가 더 빠릅니다.


DB 인덱스에서 모든 데이터의 일정한 검색 속도를 보장하는 것이 중요합니다. 그러므로 B-Tree를 개량하여 B+Tree를 만들었습니다. 

<br>
<br>

## 트랜잭션(Transaction)
트랜잭션이란 DB의 상태를 변화시키는 작업의 단위입니다.
트랜잭션을 사용하면 안정적으로 데이터를 처리하고 관리할 수 있습니다.
트랜잭션 원자성, 일관성, 고립성, 지속성 4가지 특징으로 위의 작업을 가능하게 합니다. 

<br>

* 원자성(Atomicity) : 트랜잭션 내 모든 작업은 전부 실행되거나 전부 실행되지 않아야 합니다.
* 일관성(Consistency) : 트랜잭션 실행 전과 후에 데이터베이스의 일관성이 유지되어야 합니다. 
* 고립성(Isolation) : 트랜잭션은 독립적으로 실행되어야 합니다. 트랜잭션이 실행 중일 때 다른 트랜잭션이 간섭할 수 없습니다.
* 지속성(Durability) : 트랜잭션이 성공적으로 완료되면 데이터베이스에 영구적으로 반영됩니다. 


<br>
<br>

## DB 트랜잭션 격리 수준 
데이터베이스 트랜잭션 격리 수준(Transaction Isolation Level)은 동시에 여러 트랜잭션이 실행될 때, 한 트랜잭션이 다른 트랜잭션의 중간 데이터에 접근하는 것을 
허용할지 결정하는 설정입니다. 
일반적으로 격리 수준이 높아질수록 동시성이 감소하고, 격리 수준이 낮아질수록 동시성이 증가합니다. 

<br>

트랜잭션 격리 수준은 4가지가 있습니다.
READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE 
하나씩 알아보겠습니다. 

<br>

READ UNCOMMITTED (읽기 비공유)
* 가장 낮은 격리 수준 
* 아직 커밋되지 않은 변경 사항을 다른 트랜잭션이 읽을 수 있음 
* Dirty Reads가 발생할 수 있음
* 동시성은 높지만 데이터 일관성을 보장하기 어려움

<br>

READ COMMITTED (읽기 공유)
* 한 트랜잭션이 커밋하여 확정된 변경 사항만 다른 트랜잭션이 읽을 수 있음 
* Dirty Reads는 방지되지만 Non-Repeatable Reads 발생할 수 있음. 같은 쿼리를 반복 실행할 때 다른 결과를 얻을 수 있음
* 대부분 관계형 데이터베이스 시스템에서 기본값으로 사용함 (MySQL, MariaDB ... )

<br>

REPEATABLE READ (반복 가능한 읽기)
* 한 트랜잭션이 시작되면 그 시점의 데이터 스냅샷을 기준으로 데이터를 읽음. 
* 즉, 트랜잭션 내에서 같은 쿼리를 반복 실행할 때 항상 동일한 결과를 보장
* Dirty Reads, Non-Repeatable Reads는 방지되지만 Phantom Reads가 발생할 수 있음. 트랜잭션 동작 중 다른 트랜잭션이 새로운 레코드를 삽입할 경우 유령 레코드가 나타날 수 있음 

<br>

SERIALIZABLE (직렬화 가능)
* 가장 높은 격리 수준 
* 트랜잭션이 완전히 직렬화되어 순차적 실행 보장 
* Dirty Reads, Non-Repeatable Reads, Phantom Reads 모두 방지 
* 데이터 일관성을 최대로 보장하지만 동시성이 크게 감소하여 성능 오버헤드가 발생할 수 있음 

<br>
<br>

## DB 트랜잭션 격리 수준에 따른 문제점

DB 트랜잭션 격리 수준에 특정 문제를 방지할 수 있지만 다른 문제가 발생할 수 있습니다. 
DB 트랜잭션 격리 수준에 따른 문제점들로는 Dirty Reads, Non-Repeatable Reads, Phanthom Reads가 있습니다.

<br>

Dirty Reads 
* 한 트랜잭션이 아직 커밋되지 않은 데이터를 읽는 현상입니다. 
* 첫 번째 트랜잭션이 롤백될 경우, 두 번째 트랜잭션이 잘못된 데이터를 기반으로 작업을 수행합니다. 
* READ UNCOMMITTED 격리 수준에서 주로 발생합니다. 

<br>

Non-Repeatable Reads
* 한 트랜잭션 내에서 같은 쿼리를 두 번 실행할 때, 두 번의 실행 결과가 다른 현상입니다. 한 트랜잭션이 데이터를 읽은 후 다른 트랜잭션이 그 데이터를 수정하고 커밋함으로 발생합니다. 
* READ COMMITTED 격리 수준에서 Dirty Reads 방지하지만 Non-Repeatable Reads는 발생할 수 있습니다.

<br>

Phantom Reads 
* 한 트랜잭션 내에서 두 번의 범위 쿼리를 실행할 때, 첫 번째 쿼리 실행 후 두 번째 쿼리 실행 사이에 다른 트랜잭션이 새로운 레코드를 삽입하거나 삭제할 때 발생합니다. 두 번째 쿼리 결과에 새로운 레코드가 생기거나 기존의 레코드가 사라지는 현상입니다.
* REPEATABLE READ 격리 수준에서는 Non-Repeatable Reads를 방지할 수 있지만 Phantom Reads는 발생할 수 있습니다.

<br>
이 문제들은 DB 트랜잭션 격리 수준을 높이거나 락킹 메커니즘을 활용하면 해결할 수 있습니다. 


<br>
<br>

## DB Lock 
여러 사용자나 프로세스가 동시에 DB의 동일한 데이터에 접근할 때 DB는 Lock을 사용하여 해당 데이터를 사용하고 있는 사용자 외에 다른 사용자들의 접근을 제어하여 충돌을 방지합니다.
락의 종류는 대표적으로 공유락과 베타락이 있습니다.

<br>

공유락 Shared Lock 
데이터를 변경하지 않는 읽기 명령에 대해 사용하는 락으로 Read Lock 이라고도 불립니다. 
Shared 앞 글자를 따서 주로 S라 표기합니다. 

여러 사용자가 동시에 데이터를 읽어도 데이터 일관성에는 아무런 영향이 없기 때문에 공유락끼리는 동시에 접근이 가능합니다. 
하지만 그 데이터에 대한 쓰기 작업은 방지합니다. 주로 읽기 작업이 많을 때 사용 합니다. 

<br>

베타락 Exclusive Lock 
데이터 변경에 가해지는 명령들에 주어지는 락으로 Write Lock이라 불리며 X로 표기합니다.  
베타락은 데이터에 대한 동시 읽기와 쓰기를 모두 방지합니다. 이 락이 걸린 데이터는 락을 건 프로세스만 접근할 수 있으며 다른 프로세스는 그 데이터를 읽거나 수정할 수 없습니다. 

<br>
<br>

## 데드락 Dead Lock 
DB 데드락이란 두 개 이상의 트랜잭션이 서로의 자원을 기다려서 무한히 대기하는 상황을 말합니다.

데드락은 다음 4개의 조건이 충족되면 발생합니다. 
* 상호 배재 : 트랜잭션이 자원을 독점합니다.
* 소유 대기 : 트랜잭션이 자원을 하나 차지한 상태로 다른 트랜잭션의 자원을 기다린다.
* 비선점 : 트랜잭션은 다른 트랜잭션의 자원을 빼앗을 수 없습니다.
* 환형 대기 : 트랜잭션 대기가 서로 꼬리를 물어 환형 대기를 만든 형태입니다. 

<br>

데드락은 트랜잭션 작업을 정체시켜 문제가 됩니다. 데드락을 해결하기 위한 방법들이 있습니다. 

* 타임아웃 : 일정 시간이 지나면 트랜잭션을 종료합니다.
* 자동 데드락 감지 : 트랜잭션 대기 그래프 탐색을 통해 데드락 상황을 감지합니다. 데드락 상황이 감지되면 주로 진행 상태가 낮은 트랜잭션을 종료합니다. (최근에 실행된 트랜잭션)


<br>
<br>



