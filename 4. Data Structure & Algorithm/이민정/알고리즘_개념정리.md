# 알고리즘 - 이민정

<br>
<br>

## 복잡도, 빅오 표기법

알고리즘이 얼마나 효율적인지 정량화하는 데 시간 복잡도와 공간 복잡도라는 개념을 사용한다.

시간 복잡도는 알고리즘의 실행 시간을 정량화하는 것이고, 

공간 복잡도는 실행하는 데 필요한 메모리 사용량을 정량화하는 것이다. 

알고리즘의 복잡도는 주로 빅오 표기법으로 나타낸다. 빅오 표기법(big-O notation)은 입력 값(n)에 대한 수식에서 최고차항을 기준으로 알고리즘이 수행되는 최악의 시간 복잡도를 표현한다. 최고 차항을 기준으로 표현하는 이유는 연산의 수가 극한에 수렴할 때 나머지 항이 복잡도에 미치는 영향은 미미하기 때문이다. 그래서 빅오 표기법은 계수, 상수항은 무시하고 최고차항만으로 표현한다.

대표적인 빅오 표기법에는 O(1), O(log n), O(n), O(n log n), O(n^2), O(2^n), O(n!)이 있다.

<br>
<br>

## 너비 우선 탐색(BFS, Breadth-First Search)

탐색을 시작하는 정점에서 가까운 정점을 먼저 탐색하는 방식이다. 먼저 발견한 정점과 인접한 정점들을 탐색하면서 큐에 삽입한다. 이럴 경우 이전에 방문한 정점을 큐에 삽입하면 끊임없이 탐색을 반복하게 될 수 있다. 따라서 탐색한 정점을 큐에 넣기 전에 이전에 방문했는지 반드시 확인해야 한다. 

너비 우선 탐색을 하면 비가중치 그래프에서 시작 정점부터 특정 정점까지의 최단 거리를 알 수 있다. 

<br>

## 깊이 우선 탐색(DFS, Depth-First Search)

깊이 우선 탐색은 시작 정점에서 탐색 가능한 최대 깊이의 정점까지 탐색한다. 만약 최대 깊이인 정점에 도달했다면 방문한 정점들을 역순으로 재방문하면서 탐색 가능한 정점이 있는지 확인한다. 탐색 가능한 정점이 있다면 해당 정점부터 다시 최대 깊이 정점까지 탐색을 진행한다. 

깊이 우선 탐색은 재귀 호출 또는 스택으로 구현할 수 있다. 깊이 우선 탐색을 하면 특정 정점에서 다른 정점까지의 경로를 알 수 있다. 

<br>

## 동적 계획법(DP, Dynamic Programming)

주어진 문제를 풀기 위해, 문제를 여러 개의 하위 문제로 나누어 푸는 방법을 말한다. 동적 계획법에서는 어떤 부분 문제가 다른 문제들을 해결하는 데 사용될 수 있어, 답을 여러 번 계산하는 대신 한 번만 계산하고 그 결과를 재활용하는 메모이제이션(Memoization) 기법으로 속도를 향상시킬 수 있다.

메모이제이션 : 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 재사용함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술 

<br>

### 동적 계획법이 갖는 2가지 조건

- **중복되는 부분(작은) 문제**
    - 중복되는 부분 문제는 나눠진 부분 문제가 중복되는 경우로, 메모이제이션 기법을 사용해 중복 계산을 없앤다.
- **최적 부분 구조**
    - 최적 부분 구조를 가진다는 것은 전체 문제의 최적해가 부분 문제의 최적해들로써 구성된다는 것이다.
    
<br>

## 버블 정렬(Bubble Sort)

- 비교 기반 정렬 알고리즘인 버블 정렬은 서로 인접한 두 값을 비교하면서 크기 순으로 정렬한다. 버블 정렬하면 배열의 뒤에서부터 정렬된다.
- 0번 인덱스부터 n-1번 인덱스까지 n번까지의 모든 인덱스를 비교하며 정렬하므로 O(n^2)의 시간 복잡도가 소요된다.

<br>

## 선택 정렬(Selection Sort)

- 비교 기반 정렬 알고리즘인 선택 정렬은 배열을 순회하면서 배열의 앞에서부터 차례대로 각 인덱스에 들어갈 값을 선택해 위치시킨다.
- 오름차순으로 정렬한다면 배열의 첫 번째 자리에는 최솟값을 위치시키고, 배열의 두 번째 자리에는 배열에서 최솟값 다음으로 작은 값을 위치시킨다.
- 배열의 크기를 n이라고 할 때, 각 인덱스 i에 들어갈 숫자를 찾기 위해 n-i개의 값을 비교한다. 따라서 O(n^2)의 시간 복잡도가 소요된다.

<br>

## 삽입 정렬(Insertion Sort)

- 비교 기반 정렬 알고리즘인 삽입 정렬은 배열을 앞에서부터 순회하면서 정렬된 부분의 적절한 위치에 값을 삽입하는 방식이다.
- 삽입 정렬은 전체 배열을 순회하며 각 순회에서 인덱스 i 요소를 적절한 위치에 삽입하기 위해 최대 n-i번을 탐색한다. 따라서 O(n^2)의 시간 복잡도가 소요된다.

<br>

## 합병 정렬(Merge Sort)

- 비교 기반 정렬 알고리즘인 합병 정렬은 재귀를 이용하는 분할 정복 알고리즘이다. 분할은 배열을 쪼개는 것이고, 정복은 분할한 배열을 정렬하면서 하나로 합병하는 것을 의미한다.
- 그래서 정렬하려는 배열을 크기가 0 또는 1이 될 때까지 절반씩 분할한다. 분할된 각각의 배열은 다시 하나의 배열로 합쳐지면서 정렬을 수행한다.
- 시간 복잡도는 O(n log n)이다. O(n)은 배열이 정렬되는 데 걸리는 시간 복잡도이고, O(log n)은 배열의 분할 또는 합병 시 걸리는 시간 복잡도다. 합병 단계에서 배열의 정렬이 일어나므로 합병 정렬하는 데 총 O(n log n)이라는 시간 복잡도가 소요된다.

<br>

## 퀵 정렬(Quick Sort)

- 비교 기반 정렬 알고리즘인 퀵 정렬은 합병 정렬과 마찬가지로 분할 정복 알고리즘이다.
- 배열에서 피봇(pivot)이라는 특정 값을 선택해 피봇보다 작은 값으로 구성된 배열과 피봇보다 큰 값으로 구성된 배열로 분할해 정렬하는 방식이다.
- 피봇은 일반적으로 배열의 첫 번째 요소나 마지막 요소를 선택한다. 피봇을 기준으로 배열에서 피봇보다 작은 값은 피봇의 왼쪽으로, 피봇보다 큰 값은 오른쪽으로 옮기면서 배열을 두 개로 분할해 정렬한다.
- 분할 정복을 기반으로 한 퀵 정렬의 평균적인 시간 복잡도는 O(n log n)이다. 하지만 평균적인 시간 복잡도가 되려면 피봇을 기준으로 배열을 균등하게 분할할 수 있어야 한다. 최악의 경우 O(n^2)까지 나빠질 수도 있다.
- 따라서 피봇으로 어떤 값을 선택하느냐에 따라 퀵 정렬의 성능이 좌우된다.

<br>

## 힙 정렬(Heap Sort)

- 비교 기반 정렬 알고리즘인 힙 정렬은 최대 힙이나 최소 힙 자료구조를 이용해 정렬을 수행한다.
- 최대 힙으로 오름차순 정렬을, 최소 힙으로 내림차순 정렬을 할 수 있다.
- 시간 복잡도는 O(n log n)이다. 힙 생성 알고리즘을 수행하는 데 O(log n)이, 전체 요소가 n개여서 전체 정렬하는 데 O(n log n)이 소요된다.

<br>
<br>

## 최소 신장 트리(MST, Minimum Spanning Tree)

신장 트리는 그래프의 모든 정점을 포함하는 트리를 의미한다. 그중에서 최소 신장 트리는 가중치가 있는 그래프에서 간선의 가중치 총합이 가장 작은 신장 트리를 의미한다. 

<br>

### 프림 알고리즘(Prim algorithm)

프림 알고리즘은 그리디 알고리즘으로, 임의의 정점을 시작점으로 트리를 확장하면서 최소 신장 트리를 생성하는 방식이다. 현대 트리에 포함된 정점과 연결된 간선 중 가중치가 가장 작은 간선으로 연결된 정점을 선택하는 과정을 반복하며 모든 정점이 포함될 때까지 트리를 확장한다. 

<br>

### 크루스칼 알고리즘(Kruskal algorithm)

크루스칼 알고리즘도 그리디 알고리즘이며, 간선을 오름차순으로 정렬한 뒤 가중치가 낮은 간선을 선택하면서 최소 신장 트리를 생성하는 방식이다. 만약 특정 간선을 선택했을 때 사이클이 생성된다면 해당 간선은 선택하지 않고 다음으로 가중치가 낮은 간선을 확인한다. 이 과정을 반복하다가 모든 정점이 연결되면 알고리즘을 종료한다. 크루스칼 알고리즘에서는 가중치의 오름차순으로 간선을 정렬하는 알고리즘과, 사이클의 생성 여부를 판단하는 유니온 파인드 알고리즘을 함께 사용한다. 

두 정점을 선택하고 유니온 파인드 알고리즘을 통해 다른 그래프에 속한다고 판별되면 두 정점을 연결하고, 같은 그래프에 속한다고 판별하면 두 정점을 연결하지 않는다. 

정점을 기준으로 트리를 생성하는 프림 알고리즘과 달리 간선을 기준으로 트리를 생성한다. 

<br>

### 유니온 파인드

유니온 파인드는 2개의 원소가 같은 집합에 속하는지 판단하는 알고리즘으로, 그래프에서 2개의 노드가 같은 그래프에 속하는지 판별할 수 있다. 그래프에는 루트 노드가 없기 때문에 대표 노드를 설정해 그래프를 구분한다. 유니온은 두 노드를 하나의 그래프로 합치는 연산을, 파인드는 특정 노드가 속한 그래프의 대표 노드를 찾는 연산을 의미한다. 

<br>
<br>

## 다익스트라 알고리즘(Dijkstra algorithm)

다익스트라 알고리즘은 간선의 가중치가 음수가 아닌 경우 특정 정점에서 다른 정점까지의 최단 거리를 구하는 알고리즘이다. 시작 정점을 설정하고, 방문 가능하면서 비용이 가장 적게 드는 정점에 방문해 비용을 갱신한다. 이때 각 정점의 비용에 우선순위 큐를 사용하면 시간 복잡도 면에서 효율적일 수 있다. 

<br>

## 벨만-포드 알고리즘(Bellman-Ford algorithm)

벨만-포드 알고리즘은 특정 정점에서 다른 정점까지의 최단 거리를 구하는 알고리즘으로, 간선의 가중치가 음수인 경우에도 적용할 수 있다. 하지만 음의 사이클이 있으면 최소 비용이 무한하게 줄어들어서 알고리즘을 적용할 수 없다. 

그래프의 정점 수를 n이라고 할 때, 벨만-포드 알고리즘은 전체 간선을 n-1번 순회하며 최단 거리를 갱신한다. 간선 탐색을 n-1번 반복하는 이유는 최대 n-1개 간선을 이용해 특정 노드에서 다른 노드까지의 최단 경로를 생성할 수 있기 때문이다. 만약 n개 이상의 간선을 사용했을 때 최단 거리가 갱신된다면 이는 음의 사이클이 존재함을 의미한다. 하지만 음의 사이클이 존재한다면 최단 경로가 존재할 수 없으므로 모순이 발생한다. 즉, n개 이상의 간선을 사용해 최단 거리를 생성할 수 없다는 의미다. 따라서 최단 거리는 n-1개 이하의 간선을 탐색해서 구할 수 있다. 

<br>
<br>

## 그리디 알고리즘(Greedy algorithm)

탐욕 알고리즘이라고도 하며, 각 단계에서 최선의 선택이 모여 전역으로 최적의 해결 방안을 찾는 방식이다. 그리디 알고리즘은 2가지 조건을 만족해야 한다.

- 앞에서 선택한 결과가 나중의 선택에 영향을 주지 않아야 한다.
- 지역적인 문제에 대한 최선의 선택이 전역적인 문제에 대해서도 최적의 해여야 한다.

<br>
<br>
