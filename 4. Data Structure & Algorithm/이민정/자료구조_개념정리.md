# 자료구조 - 이민정

자료구조란 효율적인 접근 및 수정을 가능하게 하는 자료의 조직, 관리, 저장을 의미한다. 더 정확히 말해, 자료구조는 데이터 값의 모임, 또 데이터 간의 관계를 의미한다. 

<br>
<br>

# 선형 자료구조(Linear Data Structure)

선형 자료구조는 연속적으로 데이터가 나열되는 자료구조를 뜻한다. 즉, 하나의 데이터 뒤에 다른 하나의 데이터가 연결된다. 대표적인 선형 자료구조로는 배열, 리스트, 스택, 큐 등이 있다. 

<br>

## 배열(Array)

- 배열은 정해진 크기만큼 데이터가 일렬로 저장되는 정적(static) 자료구조다. 각 데이터를 배열의 요소(element)라고 하며 데이터를 가리키는 번호를 인덱스(index)라고 한다.
- 배열에서 특정 인덱스에 접근하는 데 걸리는 시간 복잡도는 O(1)이다. 첫 번째 데이터에 대한 주소 값에 (데이터 타입의 메모리 크기) X (접근하려는 데이터의 인덱스)를 더하면 되기 때문이다.
- 데이터를 검색하는 데 걸리는 시간 복잡도는 O(n)이다.
- 특정 인덱스에 새로운 데이터를 삽입하는 데 걸리는 시간 복잡도는 O(n)이고, 마지막 위치에 삽입하는 경우는 O(1)의 시간 복잡도를 가진다.
- 특정 인덱스의 데이터를 삭제하는 데 걸리는 시간 복잡도는 O(n)이고, 마지막 위치의 데이터를 삭제하는 경우는 O(1)의 시간 복잡도를 가진다.

<br>

## ArrayList

- 크기를 동적으로 조절할 수 있는 배열 기반의 리스트이다.
- 데이터의 저장순서가 유지되고 중복을 허용한다.
- 내부적으로 Object 배열을 이용해서 데이터를 순차적으로 저장한다.
- 크기가 고정되어 있는 배열과 달리 데이터 적재량에 따라 가변적으로 공간을 늘리거나 줄인다. 배열 공간이 꽉 찰 때마다 새로운 배열을 생성한 후 기존의 배열을 복사하기 때문에 효율이 떨어진다는 단점이 있다.
- 데이터를 리스트 중간에 삽입/삭제할 경우, 중간에 빈 공간이 생기지 않도록 요소들의 위치를 앞뒤로 자동으로 이동시키기 때문에 삽입/삭제 동작은 느리다. 따라서 조회를 많이 하는 경우에 사용하는 것이 좋다.

<br>

## LinkedList

- 대표적인 선형 자료구조의 하나로, 배열과 달리 크기가 정해져있지 않은 동적 자료구조다.
- 여러 개의 노드(node)로 구성되어 있고, 노드는 데이터와 다음 노드가 저장된 주소 값을 가지고 있다.
- 노드가 메모리에 연속적으로 저장되지 않아도 필요한 연산을 수행할 수 있게 한다. 때문에 데이터의 추가 및 삭제가 자유롭다. 새로운 노드가 추가되어도 기존 노드들의 위치를 변경하지 않아도 되므로 시간 면에서 효율적이다.
- 하지만 배열과 달리 인덱스가 없어서 특정 위치의 데이터에 접근하는 데 배열보다 시간이 오래 걸린다.

<br>

## Stack

- 스택은 데이터를 쌓는 형태로, 마지막에 들어온 데이터가 먼저 나가는 후입선출(LIFO, Last In First Out) 형태의 자료구조다.
- 배열과 연결 리스트를 이용해 구현할 수 있다.
- 스택은 주로 어떤 작업의 실행을 취소할 때, 웹 브라우저에서 뒤로가기 할 때 등 최근에 처리한 작업들을 하나씩 꺼낼 때 사용한다.

<br>

## Queue

- 큐는 데이터가 순차적으로 들어오는 형태로, 먼저 들어온 데이터가 먼저 나가는 선입선출(FIFO, First In First Out) 형태의 자료구조다.
- 배열과 연결 리스트를 이용해 구현할 수 있다.
- 큐를 사용하는 대표적인 예로, 운영체제에서 프로세스가 CPU를 할당받기 전까지 대기하는 준비 큐가 있다.

<br>

## Deque(Double-Ended Queue)

덱은 양쪽 끝에서 데이터의 삽입과 삭제가 모두 가능한 자료구조로, 스택과 큐를 합친 형태다. 

<br>
<br>

# 비선형 자료구조(Non-Linear Data Structure)

비선형 자료구조는 하나의 데이터 뒤에 N개의 데이터가 이어질 수 있는, 1:N 또는 N:N 구조로 데이터가 나열되는 자료구조를 뜻한다. 그래서 계층적 구조를 나타내기에 편리하다. 선형 자료구조와 달리 데이터를 하나하나 탐색하지 않아도 원하는 데이터를 찾을 수 있다는 장점 때문에 비선형 자료구조를 활용한 다양한 알고리즘이 있다. 대표적인 비선형 자료구조로는 그래프, 트리, 우선순위 큐, 힙, 해시 테이블 등이 있다.

<br>

## 그래프(Graph)

- 그래프는 데이터를 포함하는 정점(vertex)와 정점을 잇는 간선(edge)으로 구성된 자료구조다. 그래프는 간선의 방향성 유무에 따라 무방향 그래프와 방향 그래프로 구분할 수 있다.
- 무방향 그래프
    - 간선에 방향성이 없는 그래프다. 두 정점이 연결되어 있을 때 순서가 없으므로 (A, B)와 (B, A)는 동일한 간선을 의미한다.
    - 정점의 개수가 n개일 때 최대 간선의 개수는 `n X (n - 1) / 2` 이다.
- 방향 그래프
    - 간선에 방향성이 있는 그래프다. 두 정점이 연결되어 있을 때 A에서 B로 향하는 간선을 <A, B>로 표기한다. 따라서 <A, B>와 <B, A>는 다른 간선을 의미한다.
    - 정점의 개수가 n일 때 최대 간선의 개수는 `n X (n - 1)`이다.

<br>

## 트리(Tree)

- 트리는 그래프의 한 종류로 사이클이 없어서 계층적 관계를 표현할 수 있다.
- 루트 노드 (root node)
    - 부모 노드가 없는 노드로, 트리에는 하나의 루트 노드가 존재한다.
- 부모 노드(parent node)
    - 루트 노드 방향으로 연결된 노드다.
- 자식 노드(child node)
    - 루트 노드의 반대 방향으로 연결된 노드다.
- 단말 노드(leaf node)
    - 자식 노드가 없는 노드
- 형제 노드(sibling node)
    - 부모 노드가 같은 노드
- 레벨(level)
    - 루트 노드로부터 노드의 상대적 위치를 의미. 일반적으로 루트 노드의 레벨은 0이다.
- 높이(height)
    - 트리의 최대 레벨 + 1을 의미한다.
- 차수(degree)
    - 자식 노드의 개수를 나타낸다.

<br>

## 이진 트리(Binary Tree)

- 이진 트리는 자식 노드가 최대 2개인 트리다. 대표적인 이진 트리의 종류로는 완전 이진 트리, 포화 이진 트리, 이진 탐색 트리가 있다.

<br>

### 완전 이진 트리(Complete Binary Tree)

- 트리의 마지막 레벨을 제외한 모든 레벨에 노드가 채워져 있으며, 마지막 레벨은 왼쪽에서부터 오른쪽으로 노드가 채워져 있는 이진 트리다.

<br>

### 포화 이진 트리(Perfect Binary Tree)

- 트리의 마지막 레벨까지 노드가 모두 채워져 있는 이진 트리다. 따라서 포화 이진 트리는 완전 이진 트리라고 할 수 있다.

<br>

### 이진 탐색 트리(BST, Binary Search Tree)

- 한 노드의 왼쪽 서브 트리는 해당 노드의 값보다 작은 값을 가진 노드로 구성되고, 오른쪽 서브 트리는 해당 노드의 값보다 큰 값을 가진 노드로 구성된 트리다.
- 균형 잡힌 이진 탐색 트리에서는 루트 노드와 가까운 노드일수록 검색해야 하는 노드 개수가 절반으로 줄어든다. 따라서 값을 검색하는 데 O(log n)이 소요된다.
- 하지만 균형이 잡히지 않은 이진 탐색 트리에서는 검색하는 데 시간 복잡도 O(n)이 소요되므로 이진 탐색 트리를 이용하는 장점이 사라진다.
- 그래서 완전 이진 트리로 이진 탐색 트리를 구성하려면 균형 이진 탐색 트리(Balanced BST)가 필요하다. 균형 이진 탐색 트리의 대료적인 예로는 레드-블랙 트리와 AVL 트리가 있다.

<br>

### RBT(Red-Black Tree)

레드-블랙 트리는 노드가 검은색 또는 빨간색인 트리로, 정해진 규칙을 만족하면서 균형을 유지하는 트리다. 레드 블랙 트리는 이진 탐색 트리이면서 추가로 충족해야 하는 조건이 있다. 트리의 데이터에 대한 연산을 수행했을 때 다음 조건을 만족하지 못하면 회전과 색 변환을 해서 노드를 재배치해야 한다. 

- 모든 노드는 검은색 또는 빨간색이다.
- 루트 노드와 모든 단말 노드는 검은색이다.
- 단말 노드는 값을 갖지 않는다.
- 빨간색 노드의 자식 노드는 검은색이며 빨간색 노드가 연속으로 나올 수 없다.
- 루트 노드에서 임의의 단말 노드까지 경로에 검은색 노드의 개수는 모두 같다.

<br>

### AVL Tree

AVL 트리는 자가 균형 이진 탐색 트리로, 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이를 유지해 균형을 잡는 트리다. 높이 차이를 알려면 왼쪽 서브 트리의 높이에서 오른쪽 서브 트리의 높이를 뺀 값인 BF(Balance Factor)를 사용한다.

- 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이는 최대 1이다.
- 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이가 1보다 커지면 균형을 잡아 높이 차이를 줄인다.
- LL, RR, LR, RL이라는 4가지 불균형 상황이 있다. 불균형 상황이면 트리를 회전해 균형을 유지한다. 오른쪽 회전은 해당 노드를 중심으로 시계 방향 회전을, 왼쪽 회전은 해당 노드를 중심으로 반시계 방향 회전을 의미한다.

<br>

## 힙(heap)

힙은 완전 이진 트리로, 최댓값 또는 최솟값을 빠르게 찾을 수 있는 자료구조다. 우선순위 큐를 구현하는 데 자주 사용한다. 

- 최대 힙(max heap)
    - 부모 노드의 값이 자식 노드의 값보다 크거나 같은 완전 이진 트리다.
- 최소 힙(min heap)
    - 부모 노드의 값이 자식 노드의 값보다 작거나 같은 완전 이진 트리다.

<br>

## 우선순위 큐(Priority Queue)

우선순위 큐는 우선순위가 높은 데이터가 먼저 나오는 자료구조다. 큐와 동일하게 데이터 삽입과 삭제 연산을 지원한다. 데이터 삭제 연산을 수행하면 우선순위가 가장 높은 데이터를 얻을 수 있다. 

우선순위 큐를 구현하는 방식은 배열, LinkedList, 완전 이진 트리인 힙이 있다. 일반적으로 가장 효율적인 방식인 힙을 사용한다.

| 구현 방법 | 삽입 | 삭제 |
| --- | --- | --- |
| 배열(정렬 x) | O(1) | O(n) |
| LinkedList(정렬 x) | O(1) | O(n) |
| 배열(정렬) | O(n) | O(1) |
| LinkedList(정렬) | O(n) | O(1) |
| heap | O(log n) | O(log n) |

<br>
<br>

## 해시 테이블(Hash Table)

해시 테이블은 하나의 키(key)에 대해 하나의 값(value)을 저장하는 형태의 자료구조다. 키는 해시 함수를 사용해 해시를 얻을 수 있다. 해시는 값이 저장되어 있는 해시 테이블의 인덱스를 찾을 수 있는 값이다. 해시 함수에 키를 넣으면 해시 테이블에서 매칭되는 결과 값에 한 번에 접근할 수 있다. 따라서 연산은 평균적으로 O(1)의 시간 복잡도를 갖는다. 

하지만 해시 테이블에는 **해시 충돌**이라는 단점이 있다. 해시 충돌은 서로 다른 키에 대해 같은 해시가 도출되는 것을 말한다. 해시 충돌을 해결하기 위한 방법에는 **체이닝**과 **개방 주소법**이 있다. 

<br>

### 체이닝(chaining)

해시 충돌이 발생하면 같은 해시가 나오는 키의 값을 LinkedList에 저장하는 방식이다. LinkedList에 노드를 저장하므로 저장 공간에 대한 제약이 적다는 장점이 있다. 하지만 하나의 해시(인덱스)에 노드가 몰릴 수 있다는 단점이 있다.

### 개방 주소법(open addressing)

해시 충돌이 발생했을 때 해당 해시가 아닌 비어 있는 공간에 값을 저장하는 방식이다. 개방 주소법에는 선형 조사법, 이차 조사법, 이중 해싱이 있다.

- **선형 조사법(linear probing)**
    - h[n]에서 해시 충돌이 발생하면 h[n+1], h[n+2]와 같이 다음 인덱스로 이동하면서 빈 공간을 찾는 방식이다.
    - 선형 조사법은 충돌이 발생하면 다음 인덱스에 데이터를 저장하므로 특정 인덱스 범위에 데이터가 몰리는 군집화 현상이 나타나는 단점이 있다.
- **이차 조사법(quadratic probing)**
    - 이차는 거듭제곱을 의미한다. h[n]에서 충돌이 발생하면 h[n+1x1], h[n+2x2], h[n+3x3]과 같이 거듭제곱한 인덱스만큼 이동하고 빈 공간을 찾으면 데이터를 저장하는 방식이다.
    - 이차 조사법은 선형 조사법보다 군집화 현상이 적지만, 완전히 해결한다고 할 수는 없다.
- **이중 해싱(double hashing)**
    - 해시 충돌이 발생하면 다른 해시 함수를 한 번 더 적용하는 방법.

<br>
