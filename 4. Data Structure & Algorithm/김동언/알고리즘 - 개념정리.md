# 알고리즘
## 개념 정리 

---


### DP
문제를 여러 개의 하위 문제로 나누어 푸는 방법입니다.

DP에서는 어떤 부분 문제의 정답이 다른 문제들을 해결하는데 사용될 수 있습니다.

답을 여러 번 계산하는 대신 한 번만 계산하고 그 결과를 메모제이션 기법으로 재활용하여 속도를 향상시킬 수 있습니다.

메모제이션 : 이전에 계산한 값을 재사용하여 동일한 계산 반복 수행을 제거하여 실행 속도를 빠르게 하는 기술



### 재귀 알고리즘
재귀 알고리즘이란 함수 내부에서 함수가 자기 자신을 다시 호출하여 문제를 해결하는 알고리즘입니다.

자기 자신을 계속해 호출하여 무한히 반복되므로 반드시 중단 조건을 설정해야 합니다.

재귀를 사용하면 간결하게 코드를 작성할 수 있습니다.

하지만 재구의 깊이가 깊어질수록 더 많은 메모리가 사용될 수 있습니다.

재귀 알고리즘의 예시로는 팩토리얼 계산, 피보나치 수열, 퀵 정렬, 병합 정렬 등이 있습니다.


### 정렬 알고리즘
정렬 알고리즘은 데이터 요소를 특정 순서대로 배열하는 알고리즘입니다.

정렬은 크게 비교 기반 정렬, 비교 기반이 아닌 정렬이 있습니다.

비교 기반 정렬은 요소 간의 비교를 통해 정렬을 수행합니다. 비교 기반이 아닌 정렬은 요소의 특성(자릿수, 키의 값)을 사용하여 정렬을 수행합니다.

비교 기반 정렬

- 버블 정렬
- 선택 정렬
- 삽입 정렬
- 병합 정렬
- 퀵 정렬
- 힙 정렬

비교 기반 아닌 정렬

- 계수 정렬
- 기수 정렬


### 버블 정렬 (Bubble Sort)

서로 인접한 두 원소를 비교하여 정렬하는 알고리즘입니다.

값이 크면 오른쪽으로 넘깁니다. 이 전체 비교를 n번 반복합니다. 그러면 오른쪽부터 큰 값이 쌓이게 되어 정렬이 완성됩니다. 거품(버블)이 피어오르듯이 큰 값이 오른쪽으로 정렬되어 버블 정렬이라 합니다.

시간 복잡도는 O(n^2) 입니다.


### 선택 정렬 (Selection Sort)

전체 배열을 탐색하여 가장 작은 값을 찾습니다. 찾은 가장 작은 값을 맨 앞의 값과 교환합니다. 그 다음, 첫 번째를 제외한 값을 탐색해 제일 작은 값을 찾습니다. 이 값을 맨 앞에서 두 번째의 값과 교환합니다.

이 작업을 n번 반복하여 정렬을 완성합니다.

가장 작은 값을 선택하여 정렬시키므로 선택 정렬이라 부릅니다. 

시간 복잡도는 O(n^2) 입니다.


### 삽입 정렬 (Insertion Sort)

요소를 왼쪽으로 보냅니다. 왼쪽에 값이 자신보다 작다면 멈춥니다. 이 과정을 반복하면 왼쪽에는 정렬된 구간이 생성됩니다. 요소들을 정렬된 구간에 있어야 할 위치에 정렬시키는 모습이 삽입하는 것과 같아 삽입 정렬이라 합니다.

시간 복잡도는 O(n^2) 입니다.

버블 정렬, 선택 정렬보다 빠릅니다.


### 힙 정렬 (Heap Sort)

힙 자료 구조를 이용한 정렬 방법입니다.

주어진 배열을 힙 자료 구조로 바꿉니다.

루트 노드의 값을 빼서 배열의 앞부터 배치합니다.

루트 노드를 뺀 힙 자료 구조에는 다시 재조정 작업을 거쳐 루트 노드에 최소값을 위치합니다.

이 과정을 반복하여 정렬을 완성합니다.

시간 복잡도는 O(n log n) 입니다.

힙 정렬이 유용한 경우는 전체를 정렬하는 경우가 아니라 가장 큰 값 혹은 가장 작은 값 몇 개를 찾을 때 입니다.



### 병합 정렬 (Merge Sort)
배열 데이터를 가장 작은 크기인 1로 나눕니다. 그리고 옆의 집합들과 병합을 합니다. 이 때 집합의 첫 번째 값을 비교하여 작은 값을 먼저 빼서 결과 배열에 위치합니다. 이렇게 부분적으로 병합하면서 정렬을 진행하면 전체 크기가 될 때까지 이 과정을 반복합니다.

크기가 1인 배열로 분할하고 합병하면서 정렬을 진행하는 분할, 정복 알고리즘 입니다.

시간 복잡도는 O(n log n)입니다. 최악의 경우에도 O(n log n) 입니다.

분할과 병합에 추가적인 메모리가 필요합니다.


### 퀵 정렬 (Quick Sort)
배열의 한 요소를 선택합니다. 이를 피벗이라 부릅니다. 피벗을 기준으로 왼쪽에는 작은 값 오른쪽에는 큰 값을 배치합니다. 이제 왼쪽, 오른쪽에도 같은 작업을 반복합니다.

피벗 기준 왼쪽, 오른쪽 부분도 같은 작업을 반복하므로 분할 정복 알고리즘입니다.

시간 복잡도는 O(n log n)입니다. 하지만 최악의 경우 O(n^2)이 될 수도 있습니다.

평균적으로는 빠른 정렬 속도를 자랑합니다.


### 정렬 속도 비교 
일반적인 상황에서 정렬 속도 비교입니다.

퀵 정렬 > 병합 정렬 > 힙 정렬 > 삽입 정렬 > 선택 정렬 > 버블 정렬 



### Java에서 사용되는 정렬 알고리즘
듀얼 피벗 퀵 소트와 팀 소트, 2가지 정렬 알고리즘을 사용합니다.

기본 타입에는 듀얼 피벗 퀵 소트(Dual Pivot Quick Sort)를 사용합니다.
참조 타입에는 팀소트(Tim Sort)를 사용합니다.


### 듀얼 피벗 퀵 소트 (Dual Pivot Quick Sort)
Java에서 기본 타입의 배열을 정렬할 때 사용하는 알고리즘 입니다.

듀얼 피벗인 이유는 두 개의 피벗을 사용한 분할 정복 알고리즘 이기 때문입니다.

두 개의 피벗 p1, p2를 사용하여 데이터를 p1보다 작은 것, p1과 p2 사이의 것, p2 보다 큰 것으로 나눕니다.

나누어진 3구역에도 같은 과정을 반복하여 정렬을 완성합니다.

시간 복잡도는 O(n log n)입니다. 빠른 속도를 자랑합니다.

기본 타입에 사용하는 이유는 듀얼 피벗 퀵 소트가 데이터 교환에 유리하기 때문입니다. 기본 타입은 메모리에 연속적으로 배치되어있어 쉽게 접근할 수 있어 수정이 편리합니다. 이는 배열 요소의 교환의 용이함으로 이어집니다.



### 팀소트(TimSort)
Java의 참조 타입 배열을 정렬할 떄 사용하는 알고리즘 입니다.

삽입 정렬과 병합 정렬을 합친 형태입니다.

팀 소트는 많은 수의 부분으로 나눕니다. 이 부분을 런이라고 합니다. 예를 들어 50개 정도의 런으로 나눌 수 있습니다. 이 분할을 통해 크기가 큰 배열을 크기가 작은 런으로 여러 개 만듭니다. 이 작은 크기의 런에는 삽입 정렬을 수행합니다. 삽입 정렬을 통해 정렬된 런들은 인접 런들과 병합 정렬을 통해 정렬을 합니다. 이런 식으로 정렬을 완성합니다.

시간 복잡도는 O(n log n)입니다.  최악의 경우에도 O(n log n)입니다.

균등하게 나누기 떄문에 평균, 최악의 경우 모두 같은 속도를 냅니다.


### Big-O 표기법의 시간 복잡도 크기 순서

작을수록 빠르다.

O(n!) > O(2^n) > O(n^2) > O(n log n) > O(n) > O(log n) > O(1)
